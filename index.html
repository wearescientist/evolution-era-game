<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ËøõÂåñÁ∫™ÂÖÉ - Evolution Era</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0d1b2a 100%);
            height: 100vh;
            width: 100vw;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        
        /* Ê∏∏ÊàèÂÆπÂô® - ÂÖ®Â±èÂ∏ÉÂ±Ä */
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        /* È°∂ÈÉ®Áä∂ÊÄÅÊ†è - Á¥ßÂáë */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 22, 40, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            z-index: 100;
            gap: 8px;
        }
        
        .stage-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: linear-gradient(135deg, rgba(0, 200, 200, 0.3), rgba(0, 150, 255, 0.3));
            border-radius: 16px;
            font-size: 0.75em;
            white-space: nowrap;
        }
        
        .stage-badge .stage-name {
            font-weight: bold;
            color: #00ffff;
        }
        
        .stage-badge .stage-number {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85em;
        }
        
        /* ËµÑÊ∫êÊù° - Á¥ßÂáëÊ®™Âêë */
        .resources-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            justify-content: center;
            overflow-x: auto;
            scrollbar-width: none;
        }
        
        .resources-bar::-webkit-scrollbar {
            display: none;
        }
        
        .resource-mini {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8em;
            white-space: nowrap;
        }
        
        .resource-mini .icon {
            font-size: 0.9em;
        }
        
        .resource-mini .value {
            font-weight: bold;
            color: #fff;
        }
        
        .resource-mini .rate {
            font-size: 0.7em;
            color: #00ff88;
        }
        
        .resource-mini .rate.negative {
            color: #ff5555;
        }
        
        .top-stats {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* Ê∏∏ÊàèÁîªÂ∏ÉÂå∫Âüü - ÊúÄÂ§ßÂåñ */
        .game-area {
            flex: 1;
            position: relative;
            margin-top: 48px;
            margin-bottom: 0;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            touch-action: none;
        }
        
        /* ËøõÂåñËøõÂ∫¶Êù° - ÊÇ¨ÊµÆÂú®ÁîªÂ∏É‰∏ä */
        .evolution-bar {
            position: absolute;
            bottom: 12px;
            left: 12px;
            right: 12px;
            height: 36px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 18px;
            padding: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
        }
        
        .evolution-progress {
            flex: 1;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            overflow: hidden;
            position: relative;
        }
        
        .evolution-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff, #8800ff);
            border-radius: 14px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }
        
        .evolution-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .evolution-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75em;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        
        .evolve-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            color: #000;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.4;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .evolve-btn.active {
            opacity: 1;
            pointer-events: auto;
            animation: pulse 1.5s infinite;
        }
        
        .evolve-btn.active:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.6); }
        }
        
        /* Â∫ïÈÉ®ÈÉ®ÁΩ≤Èù¢Êùø - ÊÇ¨ÊµÆÊªëÂá∫ */
        .deploy-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 22, 40, 0.98);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 16px 16px 0 0;
            padding: 4px 12px 10px;
            transform: translateY(calc(100% - 32px));
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 90;
            max-height: 20vh;
            overflow-y: auto;
            touch-action: pan-y;
        }
        
        .deploy-panel.visible {
            transform: translateY(0);
        }
        
        .deploy-panel.collapsed {
            transform: translateY(calc(100% - 32px));
        }
        
        .deploy-panel-header {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            padding: 2px 0 4px;
            margin-bottom: 4px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: pan-y;
        }
        
        .deploy-panel-header:active {
            cursor: grabbing;
        }
        
        .panel-toggle-bar {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 3px 12px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            transition: all 0.2s ease;
        }
        
        .panel-toggle-bar:hover {
            background: rgba(255, 255, 255, 0.12);
        }
        
        .panel-handle {
            width: 36px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .panel-toggle-icon {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.7);
            transition: transform 0.25s ease;
        }
        
        .deploy-panel:not(.collapsed) .panel-toggle-icon {
            transform: rotate(180deg);
        }
        
        .panel-toggle-text {
            font-size: 0.65em;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 500;
        }
        
        .deploy-panel::-webkit-scrollbar {
            width: 4px;
        }
        
        .deploy-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        /* ÈÉ®ÁΩ≤Â§¥ÈÉ® */
        .deploy-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 0 2px;
        }
        
        .deploy-title {
            font-size: 0.8em;
            font-weight: bold;
            color: #00ffff;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .deploy-status {
            font-size: 0.65em;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(255, 85, 85, 0.15);
            border: 1px solid rgba(255, 85, 85, 0.3);
            color: #ff8888;
        }
        
        .deploy-status.in-range {
            background: rgba(0, 255, 136, 0.15);
            border-color: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .facility-limit {
            font-size: 0.65em;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .facility-limit span {
            color: #00ffff;
            font-weight: bold;
        }
        
        /* ÈÉ®ÁΩ≤ÊåâÈíÆÁΩëÊ†º - Êõ¥Á¥ßÂáë */
        .deploy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 5px;
            margin-bottom: 6px;
        }
        
        .deploy-btn {
            padding: 5px 8px;
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.15), rgba(0, 150, 255, 0.15));
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            text-align: left;
            font-size: 0.85em;
            min-height: 36px;
        }
        
        .deploy-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.25), rgba(0, 150, 255, 0.25));
            border-color: rgba(0, 255, 255, 0.4);
        }
        
        .deploy-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        
        .deploy-btn:active:not(:disabled) {
            transform: scale(0.97);
        }
        
        .deploy-btn-icon {
            font-size: 1.1em;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            flex-shrink: 0;
        }
        
        .deploy-btn-info {
            flex: 1;
            min-width: 0;
        }
        
        .deploy-btn-name {
            font-weight: bold;
            font-size: 0.7em;
            margin-bottom: 1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .deploy-btn-cost {
            font-size: 0.55em;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* ËÆæÊñΩÂàóË°® - Êõ¥Á¥ßÂáë */
        .facilities-section {
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 6px;
        }
        
        .facilities-title {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .facility-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .facility-item {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 6px;
            padding: 5px 8px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .facility-icon {
            font-size: 1em;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            flex-shrink: 0;
        }
        
        .facility-info {
            flex: 1;
            min-width: 0;
        }
        
        .facility-name {
            font-weight: bold;
            font-size: 0.7em;
            margin-bottom: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .facility-stats {
            font-size: 0.6em;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .facility-actions {
            display: flex;
            gap: 3px;
            flex-shrink: 0;
        }
        
        .facility-btn {
            padding: 3px 6px;
            border: none;
            border-radius: 4px;
            font-size: 0.6em;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .facility-btn.upgrade {
            background: linear-gradient(135deg, #00ff88, #00aa66);
            color: #000;
        }
        
        .facility-btn.upgrade:hover:not(:disabled) {
            transform: scale(1.05);
        }
        
        .facility-btn.upgrade:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.4);
            cursor: not-allowed;
            filter: grayscale(1);
        }
        
        .facility-btn.remove {
            background: rgba(255, 85, 85, 0.2);
            color: #ff5555;
            border: 1px solid rgba(255, 85, 85, 0.3);
            padding: 4px 6px;
        }
        
        /* Ê†áÁ≠æÈ°µ - Êõ¥Á¥ßÂáë */
        .tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px;
            border-radius: 6px;
        }
        
        .tab {
            flex: 1;
            padding: 4px 6px;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 0.7em;
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .tab.active {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Âô®ÂÆòÂàóË°® */
        .organs-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .organ-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .organ-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .organ-icon.formed {
            background: linear-gradient(135deg, #00ff88, #00aa66);
        }
        
        .organ-info {
            flex: 1;
        }
        
        .organ-name {
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 3px;
        }
        
        .organ-status {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* È¢ÜÂú∞ÁΩëÊ†º */
        .territory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .territory-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .territory-card:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .territory-card.owned {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .territory-card.contested {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }
        
        .territory-icon {
            font-size: 1.6em;
            margin-bottom: 4px;
        }
        
        .territory-name {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* È±ºÁæ§ÁªüËÆ° */
        .swarm-stats {
            background: rgba(0, 100, 200, 0.2);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            justify-content: space-around;
        }
        
        .swarm-stat {
            text-align: center;
        }
        
        .swarm-stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ffff;
        }
        
        .swarm-stat-label {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 2px;
        }
        
        /* ËèúÂçïÊåâÈíÆ */
        .menu-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            transition: all 0.2s ease;
        }
        
        .menu-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* ËÆæÁΩÆÈù¢Êùø */
        .settings-panel {
            position: fixed;
            top: 48px;
            right: -280px;
            width: 280px;
            height: calc(100vh - 48px);
            background: rgba(10, 22, 40, 0.98);
            backdrop-filter: blur(15px);
            border-left: 1px solid rgba(0, 255, 255, 0.15);
            padding: 16px;
            transition: right 0.3s ease;
            z-index: 95;
            overflow-y: auto;
        }
        
        .settings-panel.open {
            right: 0;
        }
        
        .settings-title {
            font-size: 1em;
            font-weight: bold;
            margin-bottom: 16px;
            color: #00ffff;
        }
        
        .settings-group {
            margin-bottom: 20px;
        }
        
        .settings-group-title {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .settings-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }
        
        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .settings-btn.danger {
            color: #ff5555;
            border-color: rgba(255, 85, 85, 0.3);
        }
        
        .settings-btn.danger:hover {
            background: rgba(255, 85, 85, 0.1);
        }
        
        /* ÈÅÆÁΩ©Â±Ç */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 80;
        }
        
        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* ÊµÆÂä®ÊñáÂ≠ó */
        .floating-text {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 0.9em;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 0 10px currentColor;
            z-index: 50;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(1.1);
            }
        }
        
        /* ËøõÂåñÁâπÊïà */
        .evolution-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .evolution-effect.active {
            display: block;
        }
        
        .evolution-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #00ffff;
            border-radius: 50%;
            opacity: 0;
        }
        
        .evolution-effect.active .evolution-ring {
            animation: expandRing 2s ease-out forwards;
        }
        
        @keyframes expandRing {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 200vmax;
                height: 200vmax;
                opacity: 0;
            }
        }
        
        /* ÊàêÂ∞±ÂºπÁ™ó */
        .achievement-popup {
            position: fixed;
            top: 60px;
            right: -350px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            padding: 12px 16px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: right 0.5s ease;
            z-index: 1001;
            box-shadow: 0 5px 30px rgba(255, 140, 0, 0.4);
        }
        
        .achievement-popup.show {
            right: 12px;
        }
        
        .achievement-icon {
            font-size: 1.8em;
        }
        
        .achievement-text {
            color: #000;
        }
        
        .achievement-title {
            font-weight: bold;
            font-size: 0.95em;
        }
        
        .achievement-desc {
            font-size: 0.8em;
            opacity: 0.8;
        }
        
        /* Ëß¶Êë∏ÊéßÂà∂ÊèêÁ§∫ */
        .controls-hint {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            pointer-events: none;
            z-index: 10;
        }
        
        .control-key {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 12px;
            border-radius: 14px;
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
        }
        
        /* ËôöÊãüÊëáÊùÜ */
        .joystick-area {
            position: absolute;
            bottom: 60px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 20;
            display: none;
        }
        
        .joystick-area.active {
            display: block;
        }
        
        .joystick-base {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        .joystick-thumb {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
            transition: transform 0.1s;
        }
        
        /* ÂìçÂ∫îÂºèÈÄÇÈÖç */
        @media (min-width: 768px) {
            .deploy-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            }
            
            .resources-bar {
                gap: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .top-bar {
                height: 44px;
                padding: 0 8px;
            }
            
            .game-area {
                margin-top: 44px;
            }
            
            .resource-mini {
                font-size: 0.75em;
            }
            
            .deploy-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .territory-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Èù¢ÊùøÂÖ≥Èó≠ÊâãÊüÑ - Â∑≤ÁßªÈô§Ôºå‰ΩøÁî®Êñ∞ÁöÑ panel-toggle-bar */
        .panel-handle-legacy {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Âä†ËΩΩÊåáÁ§∫Âô® -->
    <div id="loadingIndicator" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #0a1628; display: flex; align-items: center; justify-content: center; z-index: 9999; transition: opacity 0.3s ease;">
        <div style="text-align: center; color: #00ffff;">
            <div style="font-size: 2em; margin-bottom: 10px;">üß¨</div>
            <div style="font-size: 1.2em;">ËøõÂåñÁ∫™ÂÖÉÂä†ËΩΩ‰∏≠...</div>
        </div>
    </div>
    <div class="game-container">
        <!-- È°∂ÈÉ®Áä∂ÊÄÅÊ†è -->
        <div class="top-bar">
            <div class="stage-badge">
                <span class="stage-name" id="stageName">ÂçïÁªÜËÉû</span>
                <span class="stage-number">(<span id="stageNumber">1</span>/11)</span>
            </div>
            
            <div class="resources-bar" id="resourcesBar">
                <!-- Âä®ÊÄÅÁîüÊàê -->
            </div>
            
            <button class="menu-btn" onclick="game.toggleSettings()" title="ËÆæÁΩÆ">‚öôÔ∏è</button>
        </div>
        
        <!-- Ê∏∏ÊàèÂå∫Âüü -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <!-- ÊéßÂà∂ÊèêÁ§∫ -->
            <div class="controls-hint">
                <div class="control-key">WASD/ÊñπÂêëÈîÆ ÁßªÂä®</div>
                <div class="control-key">Ëß¶Êë∏ÊãñÂä®</div>
            </div>
            
            <!-- ËøõÂåñËøõÂ∫¶Êù° -->
            <div class="evolution-bar">
                <div class="evolution-progress">
                    <div class="evolution-fill" id="evolutionFill" style="width: 0%"></div>
                    <div class="evolution-text">
                        <span>ËøõÂåñËøõÂ∫¶ <span id="evolutionPercent">0%</span></span>
                    </div>
                </div>
                <button class="evolve-btn" id="evolveBtn" onclick="game.attemptEvolution()" title="ËøõÂåñ">‚ú®</button>
            </div>
        </div>
        
        <!-- Â∫ïÈÉ®ÈÉ®ÁΩ≤Èù¢Êùø -->
        <div class="deploy-panel collapsed" id="deployPanel">
            <div class="deploy-panel-header" onclick="game.toggleDeployPanel()">
                <div class="panel-toggle-bar">
                    <div class="panel-handle"></div>
                    <span class="panel-toggle-text">ÈÉ®ÁΩ≤Èù¢Êùø</span>
                    <span class="panel-toggle-icon">‚ñº</span>
                </div>
            </div>
            
            <div class="deploy-header">
                <div class="deploy-title">üöÄ ÈÉ®ÁΩ≤ËÆæÊñΩ</div>
                <div class="deploy-status" id="deployStatus">ÁßªÂä®Âà∞ËµÑÊ∫êÂå∫ÈÉ®ÁΩ≤</div>
                <div class="facility-limit">
                    <span id="facilityCount">0</span>/<span id="facilityLimit">1</span>
                </div>
            </div>
            
            <!-- Èò∂ÊÆµ1: ÂçïÁªÜËÉû -->
            <div id="unicellularContent">
                <div class="deploy-grid" id="deployGrid"></div>
                <div class="facilities-section">
                    <div class="facilities-title">Â∑≤ÈÉ®ÁΩ≤ËÆæÊñΩ</div>
                    <div class="facility-list" id="facilityList"></div>
                </div>
            </div>
            
            <!-- Èò∂ÊÆµ2: Â§öÁªÜËÉû -->
            <div id="differentiationContent" style="display: none;">
                <div class="tabs">
                    <div class="tab active" onclick="game.switchTab('deploy')">ÈÉ®ÁΩ≤</div>
                    <div class="tab" onclick="game.switchTab('facilities')">ËÆæÊñΩ</div>
                    <div class="tab" onclick="game.switchTab('organs')">Âô®ÂÆò</div>
                </div>
                
                <div class="tab-content active" id="deployTab">
                    <div class="deploy-grid" id="deployGrid2"></div>
                </div>
                
                <div class="tab-content" id="facilitiesTab">
                    <div class="facility-list" id="facilityList2"></div>
                </div>
                
                <div class="tab-content" id="organsTab">
                    <div class="organs-list" id="organsList"></div>
                </div>
            </div>
            
            <!-- Èò∂ÊÆµ3: Êµ∑Ê¥ãÁîüÁâ© -->
            <div id="marineContent" style="display: none;">
                <div class="tabs">
                    <div class="tab active" onclick="game.switchTab('deploy')">ÈÉ®ÁΩ≤</div>
                    <div class="tab" onclick="game.switchTab('territory')">È¢ÜÂú∞</div>
                    <div class="tab" onclick="game.switchTab('swarm')">È±ºÁæ§</div>
                </div>
                
                <div class="tab-content active" id="deployTab3">
                    <div class="deploy-grid" id="deployGrid3"></div>
                </div>
                
                <div class="tab-content" id="territoryTab">
                    <div class="territory-grid" id="territoryGrid"></div>
                </div>
                
                <div class="tab-content" id="swarmTab">
                    <div class="swarm-stats">
                        <div class="swarm-stat">
                            <div class="swarm-stat-value" id="swarmSize">1</div>
                            <div class="swarm-stat-label">È±ºÁæ§ËßÑÊ®°</div>
                        </div>
                        <div class="swarm-stat">
                            <div class="swarm-stat-value" id="swarmBonus">+0%</div>
                            <div class="swarm-stat-label">Âçè‰ΩúÂä†Êàê</div>
                        </div>
                        <div class="swarm-stat">
                            <div class="swarm-stat-value" id="territoryIncome">0</div>
                            <div class="swarm-stat-label">È¢ÜÂú∞Êî∂Áõä</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ËÆæÁΩÆÈù¢Êùø -->
        <div class="overlay" id="overlay" onclick="game.toggleSettings()"></div>
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-title">‚öôÔ∏è Ê∏∏ÊàèËÆæÁΩÆ</div>
            
            <div class="settings-group">
                <div class="settings-group-title">Â≠òÊ°£</div>
                <button class="settings-btn" onclick="game.saveGame(); game.toggleSettings()">
                    <span>üíæ</span> ‰øùÂ≠òÊ∏∏Êàè
                </button>
                <button class="settings-btn" onclick="game.exportSave()">
                    <span>üì§</span> ÂØºÂá∫Â≠òÊ°£
                </button>
                <button class="settings-btn" onclick="game.importSave()">
                    <span>üì•</span> ÂØºÂÖ•Â≠òÊ°£
                </button>
            </div>
            
            <div class="settings-group">
                <div class="settings-group-title">Âç±Èô©Êìç‰Ωú</div>
                <button class="settings-btn danger" onclick="game.hardReset()">
                    <span>üîÑ</span> ÈáçÁΩÆÊ∏∏Êàè
                </button>
            </div>
            
            <div class="settings-group">
                <div class="settings-group-title">ÁªüËÆ°</div>
                <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px; font-size: 0.8em; color: rgba(255,255,255,0.6);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span>ËøêË°åÊó∂Èó¥</span>
                        <span id="playTime">00:00:00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>FPS</span>
                        <span id="fpsCounter">60</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ËøõÂåñÁâπÊïà -->
    <div class="evolution-effect" id="evolutionEffect">
        <div class="evolution-ring"></div>
        <div class="evolution-ring" style="animation-delay: 0.3s"></div>
        <div class="evolution-ring" style="animation-delay: 0.6s"></div>
    </div>
    
    <!-- ÊàêÂ∞±ÂºπÁ™ó -->
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-text">
            <div class="achievement-title">ÊàêÂ∞±Ëß£ÈîÅ</div>
            <div class="achievement-desc" id="achievementDesc">ÊèèËø∞</div>
        </div>
    </div>

    <script>
        // ==================== Ê∏∏ÊàèÈÖçÁΩÆÂ∏∏Èáè ====================
        const GAME_CONFIG = {
            // Èò∂ÊÆµÂêçÁß∞
            STAGE_NAMES: ['', 'ÂçïÁªÜËÉû', 'Â§öÁªÜËÉû', 'Êµ∑Ê¥ãÁîüÁâ©', 'ÈôÜÂú∞ÁîüÁâ©'],
            
            // ËµÑÊ∫êÂÆö‰πâ
            RESOURCES: {
                nutrients: { name: 'Ëê•ÂÖª', short: 'Ëê•', icon: 'üçÉ' },
                energy: { name: 'ËÉΩÈáè', short: 'ËÉΩ', icon: '‚ö°' },
                cells: { name: 'ÁªÜËÉû', short: 'ËÉû', icon: 'üß¨' },
                signals: { name: '‰ø°Âè∑', short: '‰ø°', icon: 'üì°' },
                food: { name: 'È£üÁâ©', short: 'È£ü', icon: 'üêü' },
                swarmPoints: { name: 'Áæ§‰ΩìÁÇπ', short: 'Áæ§', icon: 'üê†' }
            },
            
            // ËÆæÊñΩÁ±ªÂûãÂÆö‰πâ
            FACILITY_TYPES: {
                1: { // Èò∂ÊÆµ1: ÂçïÁªÜËÉû
                    cilia: {
                        name: 'Á∫§ÊØõÊî∂ÈõÜÂô®',
                        icon: 'üåä',
                        cost: { nutrients: 15 },
                        description: 'Ëá™Âä®Êî∂ÈõÜÂë®Âõ¥Ëê•ÂÖª',
                        production: { nutrients: 0.8 },
                        range: 80
                    },
                    metabolism: {
                        name: '‰ª£Ë∞¢Âõä',
                        icon: '‚ö°',
                        cost: { nutrients: 25, energy: 5 },
                        description: 'Â∞ÜËê•ÂÖªËΩ¨Âåñ‰∏∫ËÉΩÈáè',
                        production: { energy: 0.5 },
                        consumption: { nutrients: 0.3 },
                        range: 60
                    },
                    membrane: {
                        name: 'ËÜúÊâ©Âº†Âô®',
                        icon: 'üõ°Ô∏è',
                        cost: { energy: 20 },
                        description: 'Â¢ûÂä†ËµÑÊ∫êÂ≠òÂÇ®‰∏äÈôê',
                        effect: { capNutrients: 50, capEnergy: 30 },
                        range: 50
                    }
                },
                2: { // Èò∂ÊÆµ2: Â§öÁªÜËÉû
                    nerveNode: {
                        name: 'Á•ûÁªèËäÇÁÇπ',
                        icon: 'üß†',
                        cost: { nutrients: 40, cells: 1 },
                        description: '‰∫ßÁîü‰ø°Âè∑ÂàÜÂ≠ê',
                        production: { signals: 0.3 },
                        range: 100
                    },
                    muscleTissue: {
                        name: 'ËÇåËÇâÁªÑÁªá',
                        icon: 'üí™',
                        cost: { nutrients: 30, cells: 1 },
                        description: '‰∫ßÁîüËÉΩÈáè',
                        production: { energy: 0.8 },
                        range: 80
                    },
                    digestiveGland: {
                        name: 'Ê∂àÂåñËÖ∫',
                        icon: 'üçΩÔ∏è',
                        cost: { nutrients: 50, cells: 1 },
                        description: 'Âê∏Êî∂ÁéØÂ¢ÉËê•ÂÖª',
                        production: { nutrients: 0.6 },
                        range: 90
                    }
                },
                3: { // Èò∂ÊÆµ3: Êµ∑Ê¥ãÁîüÁâ©
                    territoryMarker: {
                        name: 'È¢ÜÂú∞Ê†áËÆ∞',
                        icon: 'üö©',
                        cost: { food: 80 },
                        description: 'Ê†áËÆ∞È¢ÜÂú∞‰∫ßÁîüÈ£üÁâ©',
                        production: { food: 2 },
                        range: 120
                    },
                    patrolUnit: {
                        name: 'Â∑°ÈÄªÈòü',
                        icon: 'üõ°Ô∏è',
                        cost: { food: 40, swarmPoints: 15 },
                        description: '‰øùÊä§È¢ÜÂú∞',
                        effect: { defense: 1 },
                        range: 100
                    },
                    breedingGround: {
                        name: 'ÁπÅÊÆñÁÇπ',
                        icon: 'üíï',
                        cost: { food: 150, swarmPoints: 40 },
                        description: 'Ëá™Âä®Â¢ûÂä†È±ºÁæ§',
                        production: { swarmPoints: 0.2 },
                        range: 150
                    }
                }
            },
            
            // Âô®ÂÆòÂÆö‰πâ
            ORGANS: {
                heart: { 
                    name: 'ÂøÉËÑè', 
                    icon: '‚ù§Ô∏è', 
                    formed: false, 
                    required: { muscle: 3, nerve: 2 } 
                },
                brain: { 
                    name: 'Â§ßËÑë', 
                    icon: 'üß†', 
                    formed: false, 
                    required: { nerve: 5, muscle: 2 } 
                },
                digestive: { 
                    name: 'Ê∂àÂåñÁ≥ªÁªü', 
                    icon: 'üçΩÔ∏è', 
                    formed: false, 
                    required: { digestive: 3, muscle: 2 } 
                }
            },
            
            // È¢ÜÂú∞Êï∞ÊçÆ
            TERRITORY_DATA: [
                { id: 0, name: 'ÁèäÁëöÁ§ÅA', owned: true, contested: false, income: 1, x: 0.2, y: 0.3 },
                { id: 1, name: 'ÁèäÁëöÁ§ÅB', owned: false, contested: false, income: 2, x: 0.8, y: 0.3 },
                { id: 2, name: 'Êµ∑ËçâÂ∫ä', owned: false, contested: false, income: 3, x: 0.3, y: 0.7 },
                { id: 3, name: 'Ê∑±Êµ∑Ê≤ü', owned: false, contested: true, income: 5, x: 0.7, y: 0.7 },
                { id: 4, name: 'ÁÉ≠Ê∂≤Âñ∑Âè£', owned: false, contested: true, income: 8, x: 0.5, y: 0.5 },
                { id: 5, name: 'Êµ∑Â∫ïÂ≥°Ë∞∑', owned: false, contested: false, income: 4, x: 0.9, y: 0.8 }
            ],
            
            // ÂçáÁ∫ßÂÆö‰πâ
            UPGRADES: {
                speed: { level: 0, cost: 50, costType: 'energy', effect: 50 },
                efficiency: { level: 0, cost: 100, costType: 'nutrients', effect: 0.1 }
            },
            
            // ÂàùÂßãËµÑÊ∫ê
            INITIAL_RESOURCES: {
                nutrients: 10,
                energy: 0,
                cells: 1,
                signals: 0,
                nerveCells: 0,
                muscleCells: 0,
                digestiveCells: 0,
                food: 0,
                swarmPoints: 0,
                territories: 0
            },
            
            // ËµÑÊ∫ê‰∏äÈôê
            RESOURCE_CAPS: {
                nutrients: 100,
                energy: 100,
                signals: 50,
                food: 500,
                swarmPoints: 1000
            },
            
            // ËøõÂåñÊù°‰ª∂
            EVOLUTION_REQUIREMENTS: {
                1: { facilities: 2, energy: 60 },
                2: { organs: 2, facilities: 6 },
                3: { territories: 3, swarmSize: 30 }
            }
        };
        
        // ==================== Â∑•ÂÖ∑ÂáΩÊï∞ ====================
        const Utils = {
            // Ê†ºÂºèÂåñÊï∞Â≠ó
            formatNumber(num) {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            },
            
            // ËÆ°ÁÆóË∑ùÁ¶ª
            distance(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            },
            
            // ÈôêÂà∂ÂÄºÂú®ËåÉÂõ¥ÂÜÖ
            clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            },
            
            // Ê∑±Êã∑Ë¥ù
            deepClone(obj) {
                return JSON.parse(JSON.stringify(obj));
            },
            
            // ÂÆâÂÖ®ÁöÑlocalStorageÊìç‰Ωú
            storage: {
                get(key, defaultValue = null) {
                    try {
                        const item = localStorage.getItem(key);
                        return item ? JSON.parse(item) : defaultValue;
                    } catch (e) {
                        console.warn('Storage get error:', e);
                        return defaultValue;
                    }
                },
                
                set(key, value) {
                    try {
                        localStorage.setItem(key, JSON.stringify(value));
                        return true;
                    } catch (e) {
                        console.warn('Storage set error:', e);
                        return false;
                    }
                },
                
                remove(key) {
                    try {
                        localStorage.removeItem(key);
                        return true;
                    } catch (e) {
                        console.warn('Storage remove error:', e);
                        return false;
                    }
                }
            }
        };
        
        // ==================== Ê∏∏ÊàèÊ†∏ÂøÉÁ±ª ====================
        class EvolutionGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.lastTime = 0;
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsTime = 0;
                
                // Ê∏≤Êüì‰ºòÂåñ
                this.renderScheduled = false;
                this.lastRenderTime = 0;
                this.targetFrameTime = 1000 / 60;
                
                // Á¶ªÂ±èCanvasÁºìÂ≠ò
                this.offscreenCanvas = null;
                this.offscreenCtx = null;
                this.staticElementsDirty = true;
                
                // Ê∏∏ÊàèÁä∂ÊÄÅ
                this.stage = 1;
                this.playTime = 0;
                this.paused = false;
                this.settingsOpen = false;
                
                // Áé©ÂÆ∂ÊéßÂà∂
                this.player = {
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    speed: 250,
                    radius: 25,
                    targetX: null,
                    targetY: null
                };
                
                // ËæìÂÖ•Áä∂ÊÄÅ
                this.keys = {
                    w: false, a: false, s: false, d: false,
                    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false
                };
                this.touchActive = false;
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.touchId = null;
                
                // ËµÑÊ∫êÁ≥ªÁªü
                this.resources = Utils.deepClone(GAME_CONFIG.INITIAL_RESOURCES);
                this.resourceCaps = Utils.deepClone(GAME_CONFIG.RESOURCE_CAPS);
                this.resourceRates = {
                    nutrients: 0.5,
                    energy: 0,
                    signals: 0,
                    food: 0,
                    swarmPoints: 0
                };
                
                // ËÆæÊñΩÁ≥ªÁªü
                this.facilities = [];
                this.zones = [];
                this.upgrades = Utils.deepClone(GAME_CONFIG.UPGRADES);
                this.organs = Utils.deepClone(GAME_CONFIG.ORGANS);
                this.territoryData = Utils.deepClone(GAME_CONFIG.TERRITORY_DATA);
                
                this.swarmSize = 1;
                this.currentTab = 'deploy';
                this.particles = [];
                this.floatingTexts = [];
                this.lastSave = 0;
                this.achievements = new Set();
                this.wasInDeployZone = false;
                
                this.init();
            }
            
            init() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.doInit());
                } else {
                    this.doInit();
                }
            }
            
            doInit() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                const logicalWidth = this.canvas.logicalWidth || this.canvas.width || 800;
                const logicalHeight = this.canvas.logicalHeight || this.canvas.height || 600;
                
                this.player.x = logicalWidth / 2;
                this.player.y = logicalHeight / 2;
                
                this.setupInput();
                this.initZones();
                this.loadGame();
                
                this.updateResourcesUI();
                this.updateFacilityUI();
                this.updateEvolutionUI();
                
                requestAnimationFrame((t) => this.gameLoop(t));
                setInterval(() => this.secondUpdate(), 1000);
                
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.style.opacity = '0';
                    setTimeout(() => loadingIndicator.remove(), 300);
                }
            }
            
            resizeCanvas() {
                const gameArea = document.querySelector('.game-area');
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.style.width = gameArea.clientWidth + 'px';
                this.canvas.style.height = gameArea.clientHeight + 'px';
                
                this.canvas.width = Math.floor(gameArea.clientWidth * dpr);
                this.canvas.height = Math.floor(gameArea.clientHeight * dpr);
                
                this.ctx.scale(dpr, dpr);
                
                this.canvas.logicalWidth = gameArea.clientWidth;
                this.canvas.logicalHeight = gameArea.clientHeight;
                
                this.createOffscreenCanvas();
                this.staticElementsDirty = true;
            }
            
            createOffscreenCanvas() {
                if (this.offscreenCanvas) {
                    this.offscreenCanvas.width = this.canvas.logicalWidth;
                    this.offscreenCanvas.height = this.canvas.logicalHeight;
                } else {
                    this.offscreenCanvas = document.createElement('canvas');
                    this.offscreenCanvas.width = this.canvas.logicalWidth || this.canvas.width;
                    this.offscreenCanvas.height = this.canvas.logicalHeight || this.canvas.height;
                    this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                }
            }
            
            setupInput() {
                // ÈîÆÁõò‰∫ã‰ª∂
                window.addEventListener('keydown', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = false;
                    }
                });
                
                // Ëß¶Êë∏‰∫ã‰ª∂
                let touchStartTime = 0;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.touchId !== null) return;
                    
                    touchStartTime = Date.now();
                    const touch = e.touches[0];
                    this.touchId = touch.identifier;
                    const rect = this.canvas.getBoundingClientRect();
                    this.touchStartX = touch.clientX - rect.left;
                    this.touchStartY = touch.clientY - rect.top;
                    this.touchActive = true;
                    this.player.targetX = this.touchStartX;
                    this.player.targetY = this.touchStartY;
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touchActive || this.touchId === null) return;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === this.touchId) {
                            const touch = e.touches[i];
                            const rect = this.canvas.getBoundingClientRect();
                            this.player.targetX = touch.clientX - rect.left;
                            this.player.targetY = touch.clientY - rect.top;
                            break;
                        }
                    }
                }, { passive: false });
                
                const endTouch = (e) => {
                    e.preventDefault();
                    let found = false;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === this.touchId) {
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        this.touchActive = false;
                        this.touchId = null;
                        this.player.targetX = null;
                        this.player.targetY = null;
                    }
                };
                
                this.canvas.addEventListener('touchend', endTouch);
                this.canvas.addEventListener('touchcancel', endTouch);
                
                // Èº†Ê†áÁÇπÂáªÁßªÂä®
                let isMouseDown = false;
                this.canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = e.clientX - rect.left;
                    this.player.targetY = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const rect = this.canvas.getBoundingClientRect();
                        this.player.targetX = e.clientX - rect.left;
                        this.player.targetY = e.clientY - rect.top;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    this.player.targetX = null;
                    this.player.targetY = null;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    isMouseDown = false;
                    this.player.targetX = null;
                    this.player.targetY = null;
                });
                
                document.body.addEventListener('touchmove', (e) => {
                    if (e.target === this.canvas) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                this.setupDeployPanelSwipe();
            }
            
            setupDeployPanelSwipe() {
                const panel = document.getElementById('deployPanel');
                const header = panel.querySelector('.deploy-panel-header');
                let startY = 0;
                let startTime = 0;
                
                header.addEventListener('touchstart', (e) => {
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                }, { passive: true });
                
                header.addEventListener('touchmove', (e) => {
                    const currentY = e.touches[0].clientY;
                    const deltaY = currentY - startY;
                    
                    if (deltaY > 30 && !panel.classList.contains('collapsed')) {
                        this.toggleDeployPanel();
                        startY = currentY;
                    }
                }, { passive: true });
                
                header.addEventListener('touchend', (e) => {
                    const endTime = Date.now();
                    const deltaTime = endTime - startTime;
                    
                    if (deltaTime < 200) {
                        this.toggleDeployPanel();
                    }
                }, { passive: true });
            }
            
            initZones() {
                const zoneCount = 5;
                const width = this.canvas.logicalWidth || this.canvas.width;
                const height = this.canvas.logicalHeight || this.canvas.height;
                
                for (let i = 0; i < zoneCount; i++) {
                    this.zones.push({
                        x: (0.15 + Math.random() * 0.7) * width,
                        y: (0.15 + Math.random() * 0.7) * height,
                        radius: 60 + Math.random() * 40,
                        type: Math.random() > 0.3 ? 'nutrient' : 'energy',
                        richness: 0.5 + Math.random() * 0.5
                    });
                }
                this.staticElementsDirty = true;
            }
            
            gameLoop(timestamp) {
                const elapsed = timestamp - this.lastRenderTime;
                if (elapsed < this.targetFrameTime) {
                    requestAnimationFrame((t) => this.gameLoop(t));
                    return;
                }
                
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.lastRenderTime = timestamp;
                
                this.frameCount++;
                if (timestamp - this.lastFpsTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsTime = timestamp;
                    document.getElementById('fpsCounter').textContent = this.fps;
                }
                
                if (!this.paused) {
                    this.update(deltaTime);
                    this.render();
                }
                
                requestAnimationFrame((t) => this.gameLoop(t));
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                this.updatePlayerMovement(dt);
                this.updateResources(dt);
                this.updateParticles(dt);
                this.updateFloatingTexts(dt);
                
                if (this.stage === 2) {
                    this.updateStage2(dt);
                } else if (this.stage === 3) {
                    this.updateStage3(dt);
                }
                
                this.checkEvolution();
                this.updateDeployUI();
                
                if (Date.now() - this.lastSave > 60000) {
                    try {
                        this.saveGame();
                        this.lastSave = Date.now();
                    } catch (e) {
                        console.warn('Auto-save failed:', e);
                    }
                }
            }
            
            updatePlayerMovement(dt) {
                let dx = 0;
                let dy = 0;
                let usingKeyboard = false;
                
                if (this.keys.w || this.keys.ArrowUp) { dy -= 1; usingKeyboard = true; }
                if (this.keys.s || this.keys.ArrowDown) { dy += 1; usingKeyboard = true; }
                if (this.keys.a || this.keys.ArrowLeft) { dx -= 1; usingKeyboard = true; }
                if (this.keys.d || this.keys.ArrowRight) { dx += 1; usingKeyboard = true; }
                
                if (!usingKeyboard && this.player.targetX !== null && this.player.targetY !== null) {
                    const targetDx = this.player.targetX - this.player.x;
                    const targetDy = this.player.targetY - this.player.y;
                    const dist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                    
                    if (dist > 5) {
                        dx = targetDx / dist;
                        dy = targetDy / dist;
                    }
                }
                
                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                    }
                }
                
                const accel = 800;
                const friction = 0.85;
                
                this.player.vx += dx * accel * dt;
                this.player.vy += dy * accel * dt;
                
                this.player.vx *= friction;
                this.player.vy *= friction;
                
                const speed = Math.sqrt(this.player.vx * this.player.vx + this.player.vy * this.player.vy);
                const maxSpeed = this.player.speed + this.upgrades.speed.level * this.upgrades.speed.effect;
                if (speed > maxSpeed) {
                    this.player.vx = (this.player.vx / speed) * maxSpeed;
                    this.player.vy = (this.player.vy / speed) * maxSpeed;
                }
                
                this.player.x += this.player.vx * dt;
                this.player.y += this.player.vy * dt;
                
                const width = this.canvas.logicalWidth || this.canvas.width;
                const height = this.canvas.logicalHeight || this.canvas.height;
                this.player.x = Utils.clamp(this.player.x, this.player.radius, width - this.player.radius);
                this.player.y = Utils.clamp(this.player.y, this.player.radius, height - this.player.radius);
            }
            
            updateResources(dt) {
                this.resourceRates = { nutrients: 0, energy: 0, signals: 0, food: 0, swarmPoints: 0 };
                const efficiency = 1 + this.upgrades.efficiency.level * this.upgrades.efficiency.effect;
                
                this.resourceCaps.nutrients = 100 + this.resources.cells * 20;
                this.resourceCaps.energy = 100 + this.resources.cells * 15;
                
                this.facilities.forEach(facility => {
                    const type = this.getFacilityType(facility.type);
                    if (!type) return;
                    
                    if (type.consumption) {
                        let canConsume = true;
                        for (let [res, amount] of Object.entries(type.consumption)) {
                            if (this.resources[res] < amount * dt) {
                                canConsume = false;
                                break;
                            }
                        }
                        
                        if (canConsume) {
                            for (let [res, amount] of Object.entries(type.consumption)) {
                                this.resources[res] -= amount * dt;
                            }
                            
                            if (type.production) {
                                for (let [res, amount] of Object.entries(type.production)) {
                                    const produced = amount * efficiency * facility.level * dt;
                                    this.resources[res] = Math.min(
                                        this.resources[res] + produced,
                                        this.resourceCaps[res] || Infinity
                                    );
                                    this.resourceRates[res] += amount * efficiency * facility.level;
                                }
                            }
                        }
                    } else if (type.production) {
                        for (let [res, amount] of Object.entries(type.production)) {
                            const produced = amount * efficiency * facility.level * dt;
                            this.resources[res] = Math.min(
                                this.resources[res] + produced,
                                this.resourceCaps[res] || Infinity
                            );
                            this.resourceRates[res] += amount * efficiency * facility.level;
                        }
                    }
                    
                    if (type.effect) {
                        if (type.effect.capNutrients) {
                            this.resourceCaps.nutrients += type.effect.capNutrients;
                        }
                        if (type.effect.capEnergy) {
                            this.resourceCaps.energy += type.effect.capEnergy;
                        }
                    }
                });
                
                if (this.stage >= 3) {
                    const ownedTerritories = this.territoryData.filter(t => t.owned).length;
                    this.resources.territories = ownedTerritories;
                    const income = ownedTerritories * 2 * dt;
                    this.resources.food = Math.min(
                        this.resources.food + income,
                        this.resourceCaps.food
                    );
                    this.resourceRates.food += ownedTerritories * 2;
                    
                    const swarmBonus = Math.floor(this.swarmSize / 10) * 0.1;
                    this.resources.swarmPoints += (ownedTerritories * 0.5 * (1 + swarmBonus)) * dt;
                }
                
                if (this.stage === 1) {
                    this.resourceRates.nutrients += 0.5;
                    this.resources.nutrients = Math.min(
                        this.resources.nutrients + 0.5 * dt,
                        this.resourceCaps.nutrients
                    );
                }
                
                this.applyResourceCaps();
            }
            
            applyResourceCaps() {
                for (let key in this.resourceCaps) {
                    if (this.resources[key] > this.resourceCaps[key]) {
                        this.resources[key] = this.resourceCaps[key];
                    }
                }
            }
            
            updateStage2(dt) {
                this.checkOrgans();
            }
            
            updateStage3(dt) {
                this.swarmSize = this.resources.cells + Math.floor(this.resources.swarmPoints / 10);
            }
            
            updateParticles(dt) {
                const maxParticles = 100;
                if (this.particles.length > maxParticles) {
                    this.particles = this.particles.slice(-maxParticles);
                }
                
                this.particles = this.particles.filter(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    p.alpha = p.life / p.maxLife;
                    return p.life > 0;
                });
            }
            
            updateFloatingTexts(dt) {
                const maxFloatingTexts = 10;
                if (this.floatingTexts.length > maxFloatingTexts) {
                    const toRemove = this.floatingTexts.slice(0, this.floatingTexts.length - maxFloatingTexts);
                    toRemove.forEach(t => t.element.remove());
                    this.floatingTexts = this.floatingTexts.slice(-maxFloatingTexts);
                }
                
                this.floatingTexts = this.floatingTexts.filter(t => {
                    t.y -= 30 * dt;
                    t.life -= dt;
                    t.element.style.opacity = t.life;
                    t.element.style.transform = `translateY(${t.y - t.startY}px) scale(${1 + (1 - t.life) * 0.5})`;
                    if (t.life <= 0) {
                        t.element.remove();
                        return false;
                    }
                    return true;
                });
            }
            
            render() {
                const width = this.canvas.logicalWidth || this.canvas.width;
                const height = this.canvas.logicalHeight || this.canvas.height;
                
                if (this.staticElementsDirty && this.offscreenCtx) {
                    this.renderStaticElements(this.offscreenCtx, width, height);
                    this.staticElementsDirty = false;
                }
                
                if (this.offscreenCanvas) {
                    this.ctx.drawImage(this.offscreenCanvas, 0, 0, width, height);
                }
                
                this.renderDynamicElements(width, height);
            }
            
            renderStaticElements(ctx, width, height) {
                const bgGradient = ctx.createLinearGradient(0, 0, width, height);
                bgGradient.addColorStop(0, '#0a1628');
                bgGradient.addColorStop(0.5, '#1a2a4a');
                bgGradient.addColorStop(1, '#0d1b2a');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, width, height);
                
                this.zones.forEach(zone => {
                    const gradient = ctx.createRadialGradient(
                        zone.x, zone.y, 0,
                        zone.x, zone.y, zone.radius
                    );
                    
                    if (zone.type === 'nutrient') {
                        gradient.addColorStop(0, `rgba(0, 255, 136, ${0.15 * zone.richness})`);
                        gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                    } else if (zone.type === 'energy') {
                        gradient.addColorStop(0, `rgba(255, 200, 0, ${0.15 * zone.richness})`);
                        gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                    } else {
                        gradient.addColorStop(0, `rgba(0, 200, 255, ${0.15 * zone.richness})`);
                        gradient.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = zone.type === 'nutrient' ? 'rgba(0, 255, 136, 0.2)' : 
                                     zone.type === 'energy' ? 'rgba(255, 200, 0, 0.2)' : 'rgba(0, 200, 255, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            }
            
            renderDynamicElements(width, height) {
                this.renderFacilities();
                this.renderPlayer();
                this.renderParticles();
                
                if (this.stage === 2) {
                    this.renderStage2();
                } else if (this.stage === 3) {
                    this.renderStage3();
                }
                
                this.zones.forEach(zone => {
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    const icon = zone.type === 'nutrient' ? 'üçÉ' : zone.type === 'energy' ? '‚ö°' : 'üì°';
                    this.ctx.fillText(icon, zone.x, zone.y);
                });
            }
            
            renderFacilities() {
                this.facilities.forEach(facility => {
                    const type = this.getFacilityType(facility.type);
                    if (!type) return;
                    
                    const gradient = this.ctx.createRadialGradient(
                        facility.x, facility.y, 0,
                        facility.x, facility.y, type.range
                    );
                    gradient.addColorStop(0, 'rgba(0, 200, 255, 0.1)');
                    gradient.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(facility.x, facility.y, type.range, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.font = '24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(type.icon, facility.x, facility.y);
                    
                    if (facility.level > 1) {
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText(`Lv.${facility.level}`, facility.x, facility.y + 20);
                    }
                });
            }
            
            renderPlayer() {
                const { x, y, radius, vx, vy } = this.player;
                const time = Date.now() / 200;
                
                const pulseRadius = radius * 3 + Math.sin(time) * 5;
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, pulseRadius);
                gradient.addColorStop(0, 'rgba(0, 255, 200, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 200, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 255, 200, 0)');
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 200, 180, 0.9)';
                this.ctx.fill();
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 0.35, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 100, 150, 0.95)';
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 0.2, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(200, 255, 255, 0.8)';
                this.ctx.fill();
                
                const speed = Math.sqrt(vx * vx + vy * vy);
                if (speed > 5) {
                    const angle = Math.atan2(vy, vx);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + Math.cos(angle) * (radius + 5), y + Math.sin(angle) * (radius + 5));
                    this.ctx.lineTo(x + Math.cos(angle) * (radius + 20), y + Math.sin(angle) * (radius + 20));
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + Math.cos(angle) * (radius + 20), y + Math.sin(angle) * (radius + 20));
                    this.ctx.lineTo(x + Math.cos(angle - 0.5) * (radius + 12), y + Math.sin(angle - 0.5) * (radius + 12));
                    this.ctx.lineTo(x + Math.cos(angle + 0.5) * (radius + 12), y + Math.sin(angle + 0.5) * (radius + 12));
                    this.ctx.closePath();
                    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                    this.ctx.fill();
                }
                
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + time * 0.5;
                    const waveOffset = Math.sin(time * 2 + i) * 3;
                    const x1 = x + Math.cos(angle) * radius;
                    const y1 = y + Math.sin(angle) * radius;
                    const x2 = x + Math.cos(angle) * (radius + 10 + waveOffset);
                    const y2 = y + Math.sin(angle) * (radius + 10 + waveOffset);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.strokeStyle = `rgba(0, 255, 200, ${0.4 + Math.sin(time + i) * 0.2})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
                
                if (this.isInDeployZone()) {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius + 15, 0, Math.PI * 2);
                    this.ctx.strokeStyle = `rgba(0, 255, 136, ${0.5 + Math.sin(time * 3) * 0.3})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
            
            renderStage2() {
                const nerveFacilities = this.facilities.filter(f => f.type === 'nerveNode');
                if (nerveFacilities.length > 1) {
                    this.ctx.strokeStyle = 'rgba(136, 68, 255, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([3, 3]);
                    
                    for (let i = 0; i < nerveFacilities.length - 1; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(nerveFacilities[i].x, nerveFacilities[i].y);
                        this.ctx.lineTo(nerveFacilities[i + 1].x, nerveFacilities[i + 1].y);
                        this.ctx.stroke();
                    }
                    this.ctx.setLineDash([]);
                }
            }
            
            renderStage3() {
                this.territoryData.forEach(t => {
                    if (t.owned) {
                        const x = t.x * this.canvas.logicalWidth;
                        const y = t.y * this.canvas.logicalHeight;
                        
                        const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, 80);
                        gradient.addColorStop(0, 'rgba(0, 255, 136, 0.2)');
                        gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 80, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.font = '30px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('ü™∏', x, y);
                    }
                });
                
                const centerX = this.canvas.logicalWidth / 2;
                const centerY = this.canvas.logicalHeight / 2;
                const fishCount = Math.min(this.swarmSize, 30);
                
                for (let i = 0; i < fishCount; i++) {
                    const angle = (i / fishCount) * Math.PI * 2 + Date.now() / 3000;
                    const r = 100 + Math.sin(angle * 3) * 20;
                    const fx = centerX + Math.cos(angle) * r;
                    const fy = centerY + Math.sin(angle) * r;
                    
                    this.ctx.save();
                    this.ctx.translate(fx, fy);
                    this.ctx.rotate(angle + Math.PI / 2);
                    
                    this.ctx.fillStyle = '#00aaff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(0, 0, 12, 6, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#0088cc';
                    this.ctx.beginPath();
                    this.ctx.moveTo(-10, 0);
                    this.ctx.lineTo(-16, -4);
                    this.ctx.lineTo(-16, 4);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            renderParticles() {
                this.particles.forEach(p => {
                    this.ctx.globalAlpha = p.alpha;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
            }
            
            getFacilityType(type) {
                const types = GAME_CONFIG.FACILITY_TYPES[this.stage];
                return types ? types[type] : null;
            }
            
            getAllFacilityTypes() {
                return GAME_CONFIG.FACILITY_TYPES[this.stage] || {};
            }
            
            canDeploy(type) {
                const facilityType = this.getFacilityType(type);
                if (!facilityType) return false;
                
                for (let [res, amount] of Object.entries(facilityType.cost)) {
                    if (this.resources[res] < amount) return false;
                }
                
                const limit = this.getFacilityLimit();
                if (this.facilities.length >= limit) return false;
                
                return true;
            }
            
            getFacilityLimit() {
                if (this.stage === 1) return this.resources.cells;
                if (this.stage === 2) return this.resources.cells + this.resources.nerveCells;
                if (this.stage === 3) return Math.floor(this.swarmSize / 5) + 1;
                return 1;
            }
            
            isInDeployZone() {
                return this.zones.some(zone => {
                    const dx = this.player.x - zone.x;
                    const dy = this.player.y - zone.y;
                    return Math.sqrt(dx * dx + dy * dy) < zone.radius;
                });
            }
            
            deployFacility(type) {
                if (!this.canDeploy(type)) {
                    const facilityType = this.getFacilityType(type);
                    const inZone = this.isInDeployZone();
                    
                    if (!inZone) {
                        this.showFloatingText(this.player.x, this.player.y - 30, 'ÈúÄË¶ÅËøõÂÖ•ËµÑÊ∫êÂå∫!', '#ffaa00');
                    } else {
                        for (let [res, amount] of Object.entries(facilityType.cost)) {
                            if (this.resources[res] < amount) {
                                const resName = GAME_CONFIG.RESOURCES[res]?.name || res;
                                this.showFloatingText(this.player.x, this.player.y - 30, `${resName}‰∏çË∂≥!`, '#ff5555');
                                break;
                            }
                        }
                    }
                    return;
                }
                
                const facilityType = this.getFacilityType(type);
                
                for (let [res, amount] of Object.entries(facilityType.cost)) {
                    this.resources[res] -= amount;
                }
                
                this.facilities.push({
                    type: type,
                    x: this.player.x,
                    y: this.player.y,
                    level: 1,
                    createdAt: Date.now()
                });
                
                this.spawnParticles(this.player.x, this.player.y, 15, '#00ffff');
                this.spawnParticles(this.player.x, this.player.y, 10, '#ffffff');
                this.showFloatingText(this.player.x, this.player.y - 40, `+${facilityType.name}`, '#00ffff');
                
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
                
                this.updateFacilityUI();
                
                if (this.facilities.length >= 3 && !this.achievements.has('builder')) {
                    this.unlockAchievement('builder', 'Âª∫ËÆæËÄÖ', 'ÈÉ®ÁΩ≤3‰∏™ËÆæÊñΩ');
                }
            }
            
            upgradeFacility(index) {
                const facility = this.facilities[index];
                if (!facility) return;
                
                const upgradeCost = Math.floor(20 * Math.pow(1.5, facility.level - 1));
                
                if (this.resources.energy >= upgradeCost) {
                    this.resources.energy -= upgradeCost;
                    facility.level++;
                    
                    this.spawnParticles(facility.x, facility.y, 12, '#00ff88');
                    this.spawnParticles(facility.x, facility.y, 8, '#ffff00');
                    this.showFloatingText(facility.x, facility.y - 40, `Lv.${facility.level}!`, '#00ff88');
                    
                    if (navigator.vibrate) {
                        navigator.vibrate([30, 30, 30]);
                    }
                    
                    this.updateFacilityUI();
                } else {
                    this.showFloatingText(facility.x, facility.y - 30, 'ËÉΩÈáè‰∏çË∂≥!', '#ff5555');
                }
            }
            
            removeFacility(index) {
                const facility = this.facilities[index];
                if (!facility) return;
                
                const type = this.getFacilityType(facility.type);
                if (type) {
                    for (let [res, amount] of Object.entries(type.cost)) {
                        this.resources[res] = Math.min(
                            this.resources[res] + Math.floor(amount * 0.5),
                            this.resourceCaps[res] || Infinity
                        );
                    }
                }
                
                this.spawnParticles(facility.x, facility.y, 5, '#ff5555');
                this.facilities.splice(index, 1);
                this.updateFacilityUI();
            }
            
            updateDeployUI() {
                const inZone = this.isInDeployZone();
                const deployPanel = document.getElementById('deployPanel');
                const statusEl = document.getElementById('deployStatus');
                
                if (inZone !== this.wasInDeployZone) {
                    if (inZone) {
                        deployPanel.classList.add('visible');
                        deployPanel.classList.remove('collapsed');
                    } else {
                        deployPanel.classList.remove('visible');
                    }
                    this.wasInDeployZone = inZone;
                }
                
                if (statusEl) {
                    if (inZone) {
                        statusEl.textContent = '‚úì ÂèØÈÉ®ÁΩ≤';
                        statusEl.className = 'deploy-status in-range';
                    } else {
                        statusEl.textContent = 'ÁßªÂä®Âà∞ËµÑÊ∫êÂå∫';
                        statusEl.className = 'deploy-status';
                    }
                }
                
                if (this.frameCount % 10 !== 0) return;
                
                const gridId = this.stage === 1 ? 'deployGrid' : this.stage === 2 ? 'deployGrid2' : 'deployGrid3';
                const grid = document.getElementById(gridId);
                if (!grid) return;
                
                const types = this.getAllFacilityTypes();
                let html = '';
                
                for (let [key, type] of Object.entries(types)) {
                    const canDeployNow = this.canDeploy(key) && inZone;
                    
                    let costText = '';
                    for (let [res, amount] of Object.entries(type.cost)) {
                        const hasEnough = this.resources[res] >= amount;
                        const resShort = GAME_CONFIG.RESOURCES[res]?.short || res.substring(0, 1);
                        costText += `<span style="color: ${hasEnough ? '#00ff88' : '#ff5555'}" data-res="${res}">${amount}${resShort}</span> `;
                    }
                    
                    html += `
                        <button class="deploy-btn" onclick="game.deployFacility('${key}')" ${canDeployNow ? '' : 'disabled'}>
                            <span class="deploy-btn-icon">${type.icon}</span>
                            <div class="deploy-btn-info">
                                <div class="deploy-btn-name">${type.name}</div>
                                <div class="deploy-btn-cost">${costText}</div>
                            </div>
                        </button>
                    `;
                }
                
                if (grid.innerHTML !== html) {
                    grid.innerHTML = html;
                }
            }
            
            updateFacilityUI() {
                const listId = this.stage === 1 ? 'facilityList' : 'facilityList2';
                const listEl = document.getElementById(listId);
                if (!listEl) return;
                
                const limit = this.getFacilityLimit();
                document.getElementById('facilityCount').textContent = this.facilities.length;
                document.getElementById('facilityLimit').textContent = limit;
                
                if (this.facilities.length === 0) {
                    listEl.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.4); padding: 20px; font-size: 0.85em;">ÊöÇÊó†ËÆæÊñΩ</div>';
                    return;
                }
                
                let html = '';
                this.facilities.forEach((facility, index) => {
                    const type = this.getFacilityType(facility.type);
                    if (!type) return;
                    
                    const upgradeCost = Math.floor(20 * Math.pow(1.5, facility.level - 1));
                    const canUpgrade = this.resources.energy >= upgradeCost;
                    
                    let productionText = '';
                    if (type.production) {
                        for (let [res, amount] of Object.entries(type.production)) {
                            const resShort = GAME_CONFIG.RESOURCES[res]?.short || res.substring(0, 1);
                            productionText += `+${(amount * facility.level).toFixed(1)}/s ${resShort} `;
                        }
                    }
                    
                    html += `
                        <div class="facility-item">
                            <div class="facility-icon">${type.icon}</div>
                            <div class="facility-info">
                                <div class="facility-name">${type.name} <span style="color: #00ffff;">Lv.${facility.level}</span></div>
                                <div class="facility-stats">${productionText || type.description}</div>
                            </div>
                            <div class="facility-actions">
                                <button class="facility-btn upgrade" onclick="game.upgradeFacility(${index})" ${canUpgrade ? '' : 'disabled'} title="ÂçáÁ∫ß (${upgradeCost}ËÉΩ)">
                                    ‚¨ÜÔ∏è
                                </button>
                                <button class="facility-btn remove" onclick="game.removeFacility(${index})" title="ÊãÜÈô§">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                listEl.innerHTML = html;
            }
            
            checkOrgans() {
                const nerveCount = this.facilities.filter(f => f.type === 'nerveNode').length;
                const muscleCount = this.facilities.filter(f => f.type === 'muscleTissue').length;
                const digestiveCount = this.facilities.filter(f => f.type === 'digestiveGland').length;
                
                if (!this.organs.heart.formed &&
                    muscleCount >= this.organs.heart.required.muscle &&
                    nerveCount >= this.organs.heart.required.nerve) {
                    this.organs.heart.formed = true;
                    this.unlockAchievement('heart', 'ÂøÉËÑèÂΩ¢Êàê', 'ÂΩ¢ÊàêÂøÉËÑèÂô®ÂÆò');
                }
                
                if (!this.organs.brain.formed &&
                    nerveCount >= this.organs.brain.required.nerve &&
                    muscleCount >= this.organs.brain.required.muscle) {
                    this.organs.brain.formed = true;
                    this.unlockAchievement('brain', 'Â§ßËÑëÂΩ¢Êàê', 'ÂΩ¢ÊàêÂ§ßËÑëÂô®ÂÆò');
                }
                
                if (!this.organs.digestive.formed &&
                    digestiveCount >= this.organs.digestive.required.digestive &&
                    muscleCount >= this.organs.digestive.required.muscle) {
                    this.organs.digestive.formed = true;
                    this.unlockAchievement('digestive', 'Ê∂àÂåñÁ≥ªÁªü', 'ÂΩ¢ÊàêÊ∂àÂåñÁ≥ªÁªü');
                }
            }
            
            checkEvolution() {
                let progress = 0;
                let canEvolve = false;
                const reqs = GAME_CONFIG.EVOLUTION_REQUIREMENTS[this.stage];
                
                if (this.stage === 1) {
                    const facilityProgress = Math.min(this.facilities.length / reqs.facilities, 1);
                    const energyProgress = Math.min(this.resources.energy / reqs.energy, 1);
                    progress = (facilityProgress + energyProgress) / 2 * 100;
                    canEvolve = this.facilities.length >= reqs.facilities && this.resources.energy >= reqs.energy;
                } else if (this.stage === 2) {
                    const organsFormed = Object.values(this.organs).filter(o => o.formed).length;
                    const organProgress = organsFormed / 3;
                    const facilityProgress = Math.min(this.facilities.length / reqs.facilities, 1);
                    progress = (organProgress + facilityProgress) / 2 * 100;
                    canEvolve = organsFormed >= reqs.organs && this.facilities.length >= reqs.facilities;
                } else if (this.stage === 3) {
                    const territoryProgress = Math.min(this.resources.territories / reqs.territories, 1);
                    const swarmProgress = Math.min(this.swarmSize / reqs.swarmSize, 1);
                    progress = (territoryProgress + swarmProgress) / 2 * 100;
                    canEvolve = this.resources.territories >= reqs.territories && this.swarmSize >= reqs.swarmSize;
                }
                
                document.getElementById('evolutionFill').style.width = progress + '%';
                document.getElementById('evolutionPercent').textContent = Math.floor(progress) + '%';
                
                const evolveBtn = document.getElementById('evolveBtn');
                if (canEvolve) {
                    evolveBtn.classList.add('active');
                } else {
                    evolveBtn.classList.remove('active');
                }
            }
            
            updateEvolutionUI() {
                this.checkEvolution();
            }
            
            attemptEvolution() {
                const reqs = GAME_CONFIG.EVOLUTION_REQUIREMENTS[this.stage];
                let canEvolve = false;
                
                if (this.stage === 1) {
                    canEvolve = this.facilities.length >= reqs.facilities && this.resources.energy >= reqs.energy;
                } else if (this.stage === 2) {
                    const organsFormed = Object.values(this.organs).filter(o => o.formed).length;
                    canEvolve = organsFormed >= reqs.organs && this.facilities.length >= reqs.facilities;
                } else if (this.stage === 3) {
                    canEvolve = this.resources.territories >= reqs.territories && this.swarmSize >= reqs.swarmSize;
                }
                
                if (canEvolve) {
                    this.evolve();
                }
            }
            
            evolve() {
                const effect = document.getElementById('evolutionEffect');
                effect.classList.add('active');
                setTimeout(() => effect.classList.remove('active'), 2000);
                
                this.facilities = [];
                this.stage++;
                
                if (this.stage === 2) {
                    document.getElementById('unicellularContent').style.display = 'none';
                    document.getElementById('differentiationContent').style.display = 'block';
                    this.resources.cells = Math.max(this.resources.cells, 5);
                    this.unlockAchievement('multicellular', 'Â§öÁªÜËÉûÁîüÁâ©', 'ËøõÂåñÂà∞Â§öÁªÜËÉûÈò∂ÊÆµ');
                    
                    this.zones = [];
                    const width = this.canvas.logicalWidth || this.canvas.width;
                    const height = this.canvas.logicalHeight || this.canvas.height;
                    for (let i = 0; i < 6; i++) {
                        this.zones.push({
                            x: (0.1 + Math.random() * 0.8) * width,
                            y: (0.1 + Math.random() * 0.8) * height,
                            radius: 70 + Math.random() * 30,
                            type: ['nutrient', 'energy', 'signal'][Math.floor(Math.random() * 3)],
                            richness: 0.6 + Math.random() * 0.4
                        });
                    }
                    this.staticElementsDirty = true;
                } else if (this.stage === 3) {
                    document.getElementById('differentiationContent').style.display = 'none';
                    document.getElementById('marineContent').style.display = 'block';
                    this.swarmSize = this.resources.cells;
                    this.unlockAchievement('marine', 'Êµ∑Ê¥ãÁîüÁâ©', 'ËøõÂåñÂà∞Êµ∑Ê¥ãÁîüÁâ©Èò∂ÊÆµ');
                    
                    this.zones = [];
                    const cvsWidth = this.canvas.logicalWidth || this.canvas.width;
                    const cvsHeight = this.canvas.logicalHeight || this.canvas.height;
                    this.territoryData.forEach(t => {
                        if (t.owned) {
                            this.zones.push({
                                x: t.x * cvsWidth,
                                y: t.y * cvsHeight,
                                radius: 100,
                                type: 'territory',
                                richness: 1
                            });
                        }
                    });
                    this.staticElementsDirty = true;
                } else if (this.stage === 4) {
                    alert('ÊÅ≠Âñú!‰Ω†Â∑≤ÂÆåÊàêMVPÊâÄÊúâÈò∂ÊÆµ!ÂêéÁª≠ÂÜÖÂÆπÂºÄÂèë‰∏≠...');
                    this.stage = 3;
                    return;
                }
                
                this.updateStageUI();
                this.updateFacilityUI();
                this.saveGame();
            }
            
            updateStageUI() {
                document.getElementById('stageName').textContent = GAME_CONFIG.STAGE_NAMES[this.stage];
                document.getElementById('stageNumber').textContent = this.stage;
            }
            
            secondUpdate() {
                this.playTime++;
                const hours = Math.floor(this.playTime / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((this.playTime % 3600) / 60).toString().padStart(2, '0');
                const seconds = (this.playTime % 60).toString().padStart(2, '0');
                document.getElementById('playTime').textContent = `${hours}:${minutes}:${seconds}`;
                
                this.updateUI();
            }
            
            updateUI() {
                this.updateResourcesUI();
                this.updateFacilityUI();
                
                if (this.stage === 2) {
                    this.updateStage2UI();
                } else if (this.stage === 3) {
                    this.updateStage3UI();
                }
            }
            
            updateResourcesUI() {
                const bar = document.getElementById('resourcesBar');
                let html = '';
                
                const resourcesToShow = [
                    { key: 'nutrients', icon: 'üçÉ' },
                    { key: 'energy', icon: '‚ö°' }
                ];
                
                if (this.stage >= 2) {
                    resourcesToShow.push({ key: 'signals', icon: 'üì°' });
                }
                
                if (this.stage >= 3) {
                    resourcesToShow.push({ key: 'food', icon: 'üêü' });
                }
                
                resourcesToShow.forEach(res => {
                    html += this.createResourceMini(res.icon, this.resources[res.key], this.resourceRates[res.key]);
                });
                
                bar.innerHTML = html;
            }
            
            createResourceMini(icon, value, rate) {
                const rateStr = rate > 0 ? `+${Utils.formatNumber(rate)}/s` : (rate < 0 ? `${Utils.formatNumber(rate)}/s` : '');
                const rateClass = rate >= 0 ? 'rate' : 'rate negative';
                
                return `
                    <div class="resource-mini">
                        <span class="icon">${icon}</span>
                        <span class="value">${Utils.formatNumber(value)}</span>
                        ${rateStr ? `<span class="${rateClass}">${rateStr}</span>` : ''}
                    </div>
                `;
            }
            
            updateStage2UI() {
                const organsList = document.getElementById('organsList');
                if (!organsList) return;
                
                const nerveCount = this.facilities.filter(f => f.type === 'nerveNode').length;
                const muscleCount = this.facilities.filter(f => f.type === 'muscleTissue').length;
                const digestiveCount = this.facilities.filter(f => f.type === 'digestiveGland').length;
                
                const organs = [
                    { key: 'heart', name: 'ÂøÉËÑè', icon: '‚ù§Ô∏è', desc: `ÈúÄ:ËÇå√ó${this.organs.heart.required.muscle}Á•û√ó${this.organs.heart.required.nerve}` },
                    { key: 'brain', name: 'Â§ßËÑë', icon: 'üß†', desc: `ÈúÄ:Á•û√ó${this.organs.brain.required.nerve}ËÇå√ó${this.organs.brain.required.muscle}` },
                    { key: 'digestive', name: 'Ê∂àÂåñÁ≥ªÁªü', icon: 'üçΩÔ∏è', desc: `ÈúÄ:Ê∂à√ó${this.organs.digestive.required.digestive}ËÇå√ó${this.organs.digestive.required.muscle}` }
                ];
                
                let html = '';
                organs.forEach(o => {
                    const formed = this.organs[o.key].formed;
                    html += `
                        <div class="organ-item">
                            <div class="organ-icon ${formed ? 'formed' : ''}">${o.icon}</div>
                            <div class="organ-info">
                                <div class="organ-name">${o.name}</div>
                                <div class="organ-status">${formed ? 'Â∑≤ÂΩ¢Êàê ‚úì' : o.desc}</div>
                            </div>
                        </div>
                    `;
                });
                
                organsList.innerHTML = html;
            }
            
            updateStage3UI() {
                const territoryGrid = document.getElementById('territoryGrid');
                if (!territoryGrid) return;
                
                let html = '';
                this.territoryData.forEach(t => {
                    const className = t.owned ? 'owned' : (t.contested ? 'contested' : '');
                    const icon = t.owned ? 'ü™∏' : (t.contested ? '‚öîÔ∏è' : '‚ùì');
                    html += `
                        <div class="territory-card ${className}">
                            <div class="territory-icon">${icon}</div>
                            <div class="territory-name">${t.name}</div>
                        </div>
                    `;
                });
                territoryGrid.innerHTML = html;
                
                document.getElementById('swarmSize').textContent = this.swarmSize;
                const bonus = Math.floor(this.swarmSize / 10) * 10;
                document.getElementById('swarmBonus').textContent = `+${bonus}%`;
                const income = this.territoryData.filter(t => t.owned).length * 2;
                document.getElementById('territoryIncome').textContent = income;
            }
            
            switchTab(tab) {
                this.currentTab = tab;
                
                const activeContent = this.stage === 2 ? 'differentiationContent' : 'marineContent';
                const panel = document.getElementById(activeContent);
                if (!panel) return;
                
                panel.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                panel.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                
                event.target.classList.add('active');
                
                const tabEl = document.getElementById(tab + 'Tab') || document.getElementById(tab + 'Tab3');
                if (tabEl) tabEl.classList.add('active');
            }
            
            toggleDeployPanel() {
                const panel = document.getElementById('deployPanel');
                panel.classList.toggle('collapsed');
            }
            
            toggleSettings() {
                this.settingsOpen = !this.settingsOpen;
                document.getElementById('settingsPanel').classList.toggle('open', this.settingsOpen);
                document.getElementById('overlay').classList.toggle('active', this.settingsOpen);
            }
            
            unlockAchievement(id, title, desc) {
                if (this.achievements.has(id)) return;
                
                this.achievements.add(id);
                
                const popup = document.getElementById('achievementPopup');
                document.getElementById('achievementDesc').textContent = `${title}: ${desc}`;
                popup.classList.add('show');
                
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 3000);
            }
            
            spawnParticles(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = 50 + Math.random() * 50;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 0.5 + Math.random() * 0.5,
                        maxLife: 1,
                        alpha: 1,
                        size: 2 + Math.random() * 3,
                        color: color
                    });
                }
            }
            
            showFloatingText(x, y, text, color) {
                const element = document.createElement('div');
                element.className = 'floating-text';
                element.textContent = text;
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                element.style.color = color;
                document.querySelector('.game-area').appendChild(element);
                
                this.floatingTexts.push({
                    element: element,
                    x: x, y: y, startY: y, life: 1
                });
            }
            
            saveGame() {
                const saveData = {
                    stage: this.stage,
                    playTime: this.playTime,
                    resources: this.resources,
                    resourceCaps: this.resourceCaps,
                    facilities: this.facilities,
                    upgrades: this.upgrades,
                    organs: this.organs,
                    territoryData: this.territoryData,
                    swarmSize: this.swarmSize,
                    achievements: Array.from(this.achievements),
                    player: { x: this.player.x, y: this.player.y },
                    lastSave: Date.now()
                };
                
                if (Utils.storage.set('evolutionGameSave', saveData)) {
                    this.showFloatingText(this.canvas.logicalWidth / 2, this.canvas.logicalHeight - 50, 'Â∑≤‰øùÂ≠ò!', '#00ff88');
                } else {
                    this.showFloatingText(this.canvas.logicalWidth / 2, this.canvas.logicalHeight - 50, '‰øùÂ≠òÂ§±Ë¥•', '#ff5555');
                }
            }
            
            loadGame() {
                const saveData = Utils.storage.get('evolutionGameSave');
                if (!saveData) return;
                
                try {
                    this.stage = saveData.stage || 1;
                    this.playTime = saveData.playTime || 0;
                    this.resources = { ...this.resources, ...saveData.resources };
                    this.resourceCaps = { ...this.resourceCaps, ...saveData.resourceCaps };
                    this.facilities = saveData.facilities || [];
                    this.upgrades = { ...this.upgrades, ...saveData.upgrades };
                    this.organs = saveData.organs || this.organs;
                    this.territoryData = saveData.territoryData || this.territoryData;
                    this.swarmSize = saveData.swarmSize || 1;
                    this.achievements = new Set(saveData.achievements || []);
                    
                    if (saveData.player) {
                        this.player.x = saveData.player.x || this.canvas.logicalWidth / 2;
                        this.player.y = saveData.player.y || this.canvas.logicalHeight / 2;
                    }
                    
                    this.updateStageUI();
                    
                    if (this.stage === 2) {
                        document.getElementById('unicellularContent').style.display = 'none';
                        document.getElementById('differentiationContent').style.display = 'block';
                    } else if (this.stage === 3) {
                        document.getElementById('unicellularContent').style.display = 'none';
                        document.getElementById('differentiationContent').style.display = 'none';
                        document.getElementById('marineContent').style.display = 'block';
                    }
                    
                    this.updateUI();
                } catch (e) {
                    console.warn('Load failed:', e);
                }
            }
            
            exportSave() {
                const saveData = Utils.storage.get('evolutionGameSave');
                if (saveData) {
                    const blob = new Blob([JSON.stringify(saveData)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `evolution_save_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
            
            importSave() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            if (Utils.storage.set('evolutionGameSave', JSON.parse(event.target.result))) {
                                location.reload();
                            } else {
                                alert('ÂØºÂÖ•Â≠òÊ°£Â§±Ë¥•');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
            
            hardReset() {
                if (confirm('Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâËøõÂ∫¶Âêó?Ê≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç!')) {
                    Utils.storage.remove('evolutionGameSave');
                    location.reload();
                }
            }
        }
        
        // ÂÖ®Â±ÄÈîôËØØÊçïËé∑
        window.addEventListener('error', (e) => console.error('Game error:', e));
        
        // ÂêØÂä®Ê∏∏Êàè
        const game = new EvolutionGame();
    </script>
</body>
</html>
