<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ËøõÂåñÁ∫™ÂÖÉ - Evolution Era</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a2a4a 50%, #0d1b2a 100%);
            height: 100vh;
            width: 100vw;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        
        /* Ê∏∏ÊàèÂÆπÂô® - ÂÖ®Â±èÂ∏ÉÂ±Ä */
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        /* È°∂ÈÉ®Áä∂ÊÄÅÊ†è - Á¥ßÂáë */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: rgba(10, 22, 40, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            z-index: 100;
            gap: 8px;
        }
        
        .stage-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: linear-gradient(135deg, rgba(0, 200, 200, 0.3), rgba(0, 150, 255, 0.3));
            border-radius: 16px;
            font-size: 0.75em;
            white-space: nowrap;
        }
        
        .stage-badge .stage-name {
            font-weight: bold;
            color: #00ffff;
        }
        
        .stage-badge .stage-number {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85em;
        }
        
        /* ËµÑÊ∫êÊù° - Á¥ßÂáëÊ®™Âêë */
        .resources-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            justify-content: center;
            overflow-x: auto;
            scrollbar-width: none;
        }
        
        .resources-bar::-webkit-scrollbar {
            display: none;
        }
        
        .resource-mini {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8em;
            white-space: nowrap;
        }
        
        .resource-mini .icon {
            font-size: 0.9em;
        }
        
        .resource-mini .value {
            font-weight: bold;
            color: #fff;
        }
        
        .resource-mini .rate {
            font-size: 0.7em;
            color: #00ff88;
        }
        
        .resource-mini .rate.negative {
            color: #ff5555;
        }
        
        .top-stats {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* Ê∏∏ÊàèÁîªÂ∏ÉÂå∫Âüü - ÊúÄÂ§ßÂåñ */
        .game-area {
            flex: 1;
            position: relative;
            margin-top: 48px;
            margin-bottom: 0;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            touch-action: none;
        }
        
        /* ËøõÂåñËøõÂ∫¶Êù° - ÊÇ¨ÊµÆÂú®ÁîªÂ∏É‰∏ä */
        .evolution-bar {
            position: absolute;
            bottom: 12px;
            left: 12px;
            right: 12px;
            height: 36px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 18px;
            padding: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
        }
        
        .evolution-progress {
            flex: 1;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            overflow: hidden;
            position: relative;
        }
        
        .evolution-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff, #8800ff);
            border-radius: 14px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }
        
        .evolution-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .evolution-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75em;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        
        .evolve-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            color: #000;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.4;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .evolve-btn.active {
            opacity: 1;
            pointer-events: auto;
            animation: pulse 1.5s infinite;
        }
        
        .evolve-btn.active:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.6); }
        }
        
        /* Â∫ïÈÉ®ÈÉ®ÁΩ≤Èù¢Êùø - ÊÇ¨ÊµÆÊªëÂá∫ */
        .deploy-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 22, 40, 0.98);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 20px 20px 0 0;
            padding: 12px 16px 24px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 90;
            max-height: 45vh;
            overflow-y: auto;
        }
        
        .deploy-panel.visible {
            transform: translateY(0);
        }
        
        .deploy-panel::-webkit-scrollbar {
            width: 4px;
        }
        
        .deploy-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .deploy-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .deploy-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #00ffff;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .deploy-status {
            font-size: 0.75em;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(255, 85, 85, 0.15);
            border: 1px solid rgba(255, 85, 85, 0.3);
            color: #ff8888;
        }
        
        .deploy-status.in-range {
            background: rgba(0, 255, 136, 0.15);
            border-color: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .facility-limit {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .facility-limit span {
            color: #00ffff;
            font-weight: bold;
        }
        
        /* ÈÉ®ÁΩ≤ÊåâÈíÆÁΩëÊ†º - Á¥ßÂáë */
        .deploy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .deploy-btn {
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.15), rgba(0, 150, 255, 0.15));
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
        }
        
        .deploy-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 255, 200, 0.25), rgba(0, 150, 255, 0.25));
            transform: translateY(-2px);
            border-color: rgba(0, 255, 255, 0.4);
        }
        
        .deploy-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }
        
        .deploy-btn-icon {
            font-size: 1.4em;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .deploy-btn-info {
            flex: 1;
        }
        
        .deploy-btn-name {
            font-weight: bold;
            font-size: 0.8em;
            margin-bottom: 2px;
        }
        
        .deploy-btn-cost {
            font-size: 0.65em;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.3;
        }
        
        /* ËÆæÊñΩÂàóË°® - Á¥ßÂáë */
        .facilities-section {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 12px;
        }
        
        .facilities-title {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .facility-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .facility-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .facility-icon {
            font-size: 1.3em;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .facility-info {
            flex: 1;
        }
        
        .facility-name {
            font-weight: bold;
            font-size: 0.8em;
            margin-bottom: 2px;
        }
        
        .facility-stats {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .facility-actions {
            display: flex;
            gap: 6px;
        }
        
        .facility-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 6px;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .facility-btn.upgrade {
            background: linear-gradient(135deg, #00ff88, #00aa66);
            color: #000;
        }
        
        .facility-btn.upgrade:hover:not(:disabled) {
            transform: scale(1.05);
        }
        
        .facility-btn.upgrade:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.4);
            cursor: not-allowed;
        }
        
        .facility-btn.remove {
            background: rgba(255, 85, 85, 0.2);
            color: #ff5555;
            border: 1px solid rgba(255, 85, 85, 0.3);
            padding: 5px 8px;
        }
        
        /* Ê†áÁ≠æÈ°µ */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 10px;
        }
        
        .tab {
            flex: 1;
            padding: 8px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8em;
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab.active {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Âô®ÂÆòÂàóË°® */
        .organs-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .organ-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .organ-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .organ-icon.formed {
            background: linear-gradient(135deg, #00ff88, #00aa66);
        }
        
        .organ-info {
            flex: 1;
        }
        
        .organ-name {
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 3px;
        }
        
        .organ-status {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* È¢ÜÂú∞ÁΩëÊ†º */
        .territory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .territory-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .territory-card:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .territory-card.owned {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .territory-card.contested {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }
        
        .territory-icon {
            font-size: 1.6em;
            margin-bottom: 4px;
        }
        
        .territory-name {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* È±ºÁæ§ÁªüËÆ° */
        .swarm-stats {
            background: rgba(0, 100, 200, 0.2);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            justify-content: space-around;
        }
        
        .swarm-stat {
            text-align: center;
        }
        
        .swarm-stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ffff;
        }
        
        .swarm-stat-label {
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 2px;
        }
        
        /* ËèúÂçïÊåâÈíÆ */
        .menu-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            transition: all 0.2s ease;
        }
        
        .menu-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* ËÆæÁΩÆÈù¢Êùø */
        .settings-panel {
            position: fixed;
            top: 48px;
            right: -280px;
            width: 280px;
            height: calc(100vh - 48px);
            background: rgba(10, 22, 40, 0.98);
            backdrop-filter: blur(15px);
            border-left: 1px solid rgba(0, 255, 255, 0.15);
            padding: 16px;
            transition: right 0.3s ease;
            z-index: 95;
            overflow-y: auto;
        }
        
        .settings-panel.open {
            right: 0;
        }
        
        .settings-title {
            font-size: 1em;
            font-weight: bold;
            margin-bottom: 16px;
            color: #00ffff;
        }
        
        .settings-group {
            margin-bottom: 20px;
        }
        
        .settings-group-title {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .settings-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }
        
        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .settings-btn.danger {
            color: #ff5555;
            border-color: rgba(255, 85, 85, 0.3);
        }
        
        .settings-btn.danger:hover {
            background: rgba(255, 85, 85, 0.1);
        }
        
        /* ÈÅÆÁΩ©Â±Ç */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 80;
        }
        
        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* ÊµÆÂä®ÊñáÂ≠ó */
        .floating-text {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 0.9em;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 0 10px currentColor;
            z-index: 50;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(1.1);
            }
        }
        
        /* ËøõÂåñÁâπÊïà */
        .evolution-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .evolution-effect.active {
            display: block;
        }
        
        .evolution-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #00ffff;
            border-radius: 50%;
            opacity: 0;
        }
        
        .evolution-effect.active .evolution-ring {
            animation: expandRing 2s ease-out forwards;
        }
        
        @keyframes expandRing {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 200vmax;
                height: 200vmax;
                opacity: 0;
            }
        }
        
        /* ÊàêÂ∞±ÂºπÁ™ó */
        .achievement-popup {
            position: fixed;
            top: 60px;
            right: -350px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            padding: 12px 16px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: right 0.5s ease;
            z-index: 1001;
            box-shadow: 0 5px 30px rgba(255, 140, 0, 0.4);
        }
        
        .achievement-popup.show {
            right: 12px;
        }
        
        .achievement-icon {
            font-size: 1.8em;
        }
        
        .achievement-text {
            color: #000;
        }
        
        .achievement-title {
            font-weight: bold;
            font-size: 0.95em;
        }
        
        .achievement-desc {
            font-size: 0.8em;
            opacity: 0.8;
        }
        
        /* Ëß¶Êë∏ÊéßÂà∂ÊèêÁ§∫ */
        .controls-hint {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            pointer-events: none;
            z-index: 10;
        }
        
        .control-key {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 12px;
            border-radius: 14px;
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(5px);
        }
        
        /* ËôöÊãüÊëáÊùÜ */
        .joystick-area {
            position: absolute;
            bottom: 60px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 20;
            display: none;
        }
        
        .joystick-area.active {
            display: block;
        }
        
        .joystick-base {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        .joystick-thumb {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
            transition: transform 0.1s;
        }
        
        /* ÂìçÂ∫îÂºèÈÄÇÈÖç */
        @media (min-width: 768px) {
            .deploy-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            }
            
            .resources-bar {
                gap: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .top-bar {
                height: 44px;
                padding: 0 8px;
            }
            
            .game-area {
                margin-top: 44px;
            }
            
            .resource-mini {
                font-size: 0.75em;
            }
            
            .deploy-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .territory-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Èù¢ÊùøÂÖ≥Èó≠ÊâãÊüÑ */
        .panel-handle {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 0 auto 12px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- È°∂ÈÉ®Áä∂ÊÄÅÊ†è -->
        <div class="top-bar">
            <div class="stage-badge">
                <span class="stage-name" id="stageName">ÂçïÁªÜËÉû</span>
                <span class="stage-number">(<span id="stageNumber">1</span>/11)</span>
            </div>
            
            <div class="resources-bar" id="resourcesBar">
                <!-- Âä®ÊÄÅÁîüÊàê -->
            </div>
            
            <button class="menu-btn" onclick="game.toggleSettings()" title="ËÆæÁΩÆ">‚öôÔ∏è</button>
        </div>
        
        <!-- Ê∏∏ÊàèÂå∫Âüü -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <!-- ÊéßÂà∂ÊèêÁ§∫ -->
            <div class="controls-hint">
                <div class="control-key">WASD/ÊñπÂêëÈîÆ ÁßªÂä®</div>
                <div class="control-key">Ëß¶Êë∏ÊãñÂä®</div>
            </div>
            
            <!-- ËøõÂåñËøõÂ∫¶Êù° -->
            <div class="evolution-bar">
                <div class="evolution-progress">
                    <div class="evolution-fill" id="evolutionFill" style="width: 0%"></div>
                    <div class="evolution-text">
                        <span>ËøõÂåñËøõÂ∫¶ <span id="evolutionPercent">0%</span></span>
                    </div>
                </div>
                <button class="evolve-btn" id="evolveBtn" onclick="game.attemptEvolution()" title="ËøõÂåñ">‚ú®</button>
            </div>
        </div>
        
        <!-- Â∫ïÈÉ®ÈÉ®ÁΩ≤Èù¢Êùø -->
        <div class="deploy-panel" id="deployPanel">
            <div class="panel-handle"></div>
            
            <div class="deploy-header">
                <div class="deploy-title">üöÄ ÈÉ®ÁΩ≤ËÆæÊñΩ</div>
                <div class="deploy-status" id="deployStatus">ÁßªÂä®Âà∞ËµÑÊ∫êÂå∫ÈÉ®ÁΩ≤</div>
                <div class="facility-limit">
                    <span id="facilityCount">0</span>/<span id="facilityLimit">1</span>
                </div>
            </div>
            
            <!-- Èò∂ÊÆµ1: ÂçïÁªÜËÉû -->
            <div id="unicellularContent">
                <div class="deploy-grid" id="deployGrid"></div>
                <div class="facilities-section">
                    <div class="facilities-title">Â∑≤ÈÉ®ÁΩ≤ËÆæÊñΩ</div>
                    <div class="facility-list" id="facilityList"></div>
                </div>
            </div>
            
            <!-- Èò∂ÊÆµ2: Â§öÁªÜËÉû -->
            <div id="differentiationContent" style="display: none;">
                <div class="tabs">
                    <div class="tab active" onclick="game.switchTab('deploy')">ÈÉ®ÁΩ≤</div>
                    <div class="tab" onclick="game.switchTab('facilities')">ËÆæÊñΩ</div>
                    <div class="tab" onclick="game.switchTab('organs')">Âô®ÂÆò</div>
                </div>
                
                <div class="tab-content active" id="deployTab">
                    <div class="deploy-grid" id="deployGrid2"></div>
                </div>
                
                <div class="tab-content" id="facilitiesTab">
                    <div class="facility-list" id="facilityList2"></div>
                </div>
                
                <div class="tab-content" id="organsTab">
                    <div class="organs-list" id="organsList"></div>
                </div>
            </div>
            
            <!-- Èò∂ÊÆµ3: Êµ∑Ê¥ãÁîüÁâ© -->
            <div id="marineContent" style="display: none;">
                <div class="tabs">
                    <div class="tab active" onclick="game.switchTab('deploy')">ÈÉ®ÁΩ≤</div>
                    <div class="tab" onclick="game.switchTab('territory')">È¢ÜÂú∞</div>
                    <div class="tab" onclick="game.switchTab('swarm')">È±ºÁæ§</div>
                </div>
                
                <div class="tab-content active" id="deployTab3">
                    <div class="deploy-grid" id="deployGrid3"></div>
                </div>
                
                <div class="tab-content" id="territoryTab">
                    <div class="territory-grid" id="territoryGrid"></div>
                </div>
                
                <div class="tab-content" id="swarmTab">
                    <div class="swarm-stats">
                        <div class="swarm-stat">
                            <div class="swarm-stat-value" id="swarmSize">1</div>
                            <div class="swarm-stat-label">È±ºÁæ§ËßÑÊ®°</div>
                        </div>
                        <div class="swarm-stat">
                            <div class="swarm-stat-value" id="swarmBonus">+0%</div>
                            <div class="swarm-stat-label">Âçè‰ΩúÂä†Êàê</div>
                        </div>
                        <div class="swarm-stat">
                            <div class="swarm-stat-value" id="territoryIncome">0</div>
                            <div class="swarm-stat-label">È¢ÜÂú∞Êî∂Áõä</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ËÆæÁΩÆÈù¢Êùø -->
        <div class="overlay" id="overlay" onclick="game.toggleSettings()"></div>
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-title">‚öôÔ∏è Ê∏∏ÊàèËÆæÁΩÆ</div>
            
            <div class="settings-group">
                <div class="settings-group-title">Â≠òÊ°£</div>
                <button class="settings-btn" onclick="game.saveGame(); game.toggleSettings()">
                    <span>üíæ</span> ‰øùÂ≠òÊ∏∏Êàè
                </button>
                <button class="settings-btn" onclick="game.exportSave()">
                    <span>üì§</span> ÂØºÂá∫Â≠òÊ°£
                </button>
                <button class="settings-btn" onclick="game.importSave()">
                    <span>üì•</span> ÂØºÂÖ•Â≠òÊ°£
                </button>
            </div>
            
            <div class="settings-group">
                <div class="settings-group-title">Âç±Èô©Êìç‰Ωú</div>
                <button class="settings-btn danger" onclick="game.hardReset()">
                    <span>üîÑ</span> ÈáçÁΩÆÊ∏∏Êàè
                </button>
            </div>
            
            <div class="settings-group">
                <div class="settings-group-title">ÁªüËÆ°</div>
                <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px; font-size: 0.8em; color: rgba(255,255,255,0.6);">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                        <span>ËøêË°åÊó∂Èó¥</span>
                        <span id="playTime">00:00:00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>FPS</span>
                        <span id="fpsCounter">60</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ËøõÂåñÁâπÊïà -->
    <div class="evolution-effect" id="evolutionEffect">
        <div class="evolution-ring"></div>
        <div class="evolution-ring" style="animation-delay: 0.3s"></div>
        <div class="evolution-ring" style="animation-delay: 0.6s"></div>
    </div>
    
    <!-- ÊàêÂ∞±ÂºπÁ™ó -->
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-text">
            <div class="achievement-title">ÊàêÂ∞±Ëß£ÈîÅ</div>
            <div class="achievement-desc" id="achievementDesc">ÊèèËø∞</div>
        </div>
    </div>

    <script>
        // ==================== Ê∏∏ÊàèÊ†∏ÂøÉÁ±ª ====================
        class EvolutionGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.lastTime = 0;
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsTime = 0;
                
                // Ê∏∏ÊàèÁä∂ÊÄÅ
                this.stage = 1;
                this.playTime = 0;
                this.paused = false;
                this.settingsOpen = false;
                
                // Áé©ÂÆ∂ÊéßÂà∂
                this.player = {
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    speed: 250,
                    radius: 25,
                    targetX: null,
                    targetY: null
                };
                
                // ËæìÂÖ•Áä∂ÊÄÅ
                this.keys = {
                    w: false, a: false, s: false, d: false,
                    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false
                };
                this.touchActive = false;
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.touchId = null;
                
                // ËµÑÊ∫êÁ≥ªÁªü
                this.resources = {
                    nutrients: 50,
                    energy: 30,
                    cells: 1,
                    signals: 0,
                    nerveCells: 0,
                    muscleCells: 0,
                    digestiveCells: 0,
                    food: 0,
                    swarmPoints: 0,
                    territories: 0
                };
                
                this.resourceCaps = {
                    nutrients: 100,
                    energy: 100,
                    signals: 50,
                    food: 500,
                    swarmPoints: 1000
                };
                
                this.resourceRates = {
                    nutrients: 0,
                    energy: 0,
                    signals: 0,
                    food: 0,
                    swarmPoints: 0
                };
                
                // ËÆæÊñΩÁ≥ªÁªü
                this.facilities = [];
                this.facilityTypes = {
                    cilia: {
                        name: 'Á∫§ÊØõÊî∂ÈõÜÂô®',
                        icon: 'üåä',
                        cost: { nutrients: 20 },
                        description: 'Ëá™Âä®Êî∂ÈõÜÂë®Âõ¥Ëê•ÂÖª',
                        production: { nutrients: 0.5 },
                        range: 80
                    },
                    metabolism: {
                        name: '‰ª£Ë∞¢Âõä',
                        icon: '‚ö°',
                        cost: { nutrients: 30, energy: 10 },
                        description: 'Â∞ÜËê•ÂÖªËΩ¨Âåñ‰∏∫ËÉΩÈáè',
                        production: { energy: 0.3 },
                        consumption: { nutrients: 0.2 },
                        range: 60
                    },
                    membrane: {
                        name: 'ËÜúÊâ©Âº†Âô®',
                        icon: 'üõ°Ô∏è',
                        cost: { energy: 30 },
                        description: 'Â¢ûÂä†ËµÑÊ∫êÂ≠òÂÇ®‰∏äÈôê',
                        effect: { capNutrients: 50, capEnergy: 30 },
                        range: 50
                    }
                };
                
                this.facilityTypesStage2 = {
                    nerveNode: {
                        name: 'Á•ûÁªèËäÇÁÇπ',
                        icon: 'üß†',
                        cost: { nutrients: 50, cells: 1 },
                        description: '‰∫ßÁîü‰ø°Âè∑ÂàÜÂ≠ê',
                        production: { signals: 0.2 },
                        range: 100
                    },
                    muscleTissue: {
                        name: 'ËÇåËÇâÁªÑÁªá',
                        icon: 'üí™',
                        cost: { nutrients: 40, cells: 1 },
                        description: '‰∫ßÁîüËÉΩÈáè',
                        production: { energy: 0.5 },
                        range: 80
                    },
                    digestiveGland: {
                        name: 'Ê∂àÂåñËÖ∫',
                        icon: 'üçΩÔ∏è',
                        cost: { nutrients: 60, cells: 1 },
                        description: 'Âê∏Êî∂ÁéØÂ¢ÉËê•ÂÖª',
                        production: { nutrients: 0.4 },
                        range: 90
                    }
                };
                
                this.facilityTypesStage3 = {
                    territoryMarker: {
                        name: 'È¢ÜÂú∞Ê†áËÆ∞',
                        icon: 'üö©',
                        cost: { food: 100 },
                        description: 'Ê†áËÆ∞È¢ÜÂú∞‰∫ßÁîüÈ£üÁâ©',
                        production: { food: 1 },
                        range: 120
                    },
                    patrolUnit: {
                        name: 'Â∑°ÈÄªÈòü',
                        icon: 'üõ°Ô∏è',
                        cost: { food: 50, swarmPoints: 20 },
                        description: '‰øùÊä§È¢ÜÂú∞',
                        effect: { defense: 1 },
                        range: 100
                    },
                    breedingGround: {
                        name: 'ÁπÅÊÆñÁÇπ',
                        icon: 'üíï',
                        cost: { food: 200, swarmPoints: 50 },
                        description: 'Ëá™Âä®Â¢ûÂä†È±ºÁæ§',
                        production: { swarmPoints: 0.1 },
                        range: 150
                    }
                };
                
                this.zones = [];
                
                this.upgrades = {
                    speed: { level: 0, cost: 50, costType: 'energy', effect: 50 },
                    efficiency: { level: 0, cost: 100, costType: 'nutrients', effect: 0.1 }
                };
                
                this.organs = {
                    heart: { formed: false, required: { muscle: 3, nerve: 2 } },
                    brain: { formed: false, required: { nerve: 5, muscle: 2 } },
                    digestive: { formed: false, required: { digestive: 3, muscle: 2 } }
                };
                
                this.territoryData = [
                    { id: 0, name: 'ÁèäÁëöÁ§ÅA', owned: true, contested: false, income: 1, x: 0.2, y: 0.3 },
                    { id: 1, name: 'ÁèäÁëöÁ§ÅB', owned: false, contested: false, income: 2, x: 0.8, y: 0.3 },
                    { id: 2, name: 'Êµ∑ËçâÂ∫ä', owned: false, contested: false, income: 3, x: 0.3, y: 0.7 },
                    { id: 3, name: 'Ê∑±Êµ∑Ê≤ü', owned: false, contested: true, income: 5, x: 0.7, y: 0.7 },
                    { id: 4, name: 'ÁÉ≠Ê∂≤Âñ∑Âè£', owned: false, contested: true, income: 8, x: 0.5, y: 0.5 },
                    { id: 5, name: 'Êµ∑Â∫ïÂ≥°Ë∞∑', owned: false, contested: false, income: 4, x: 0.9, y: 0.8 }
                ];
                
                this.swarmSize = 1;
                this.currentTab = 'deploy';
                this.particles = [];
                this.floatingTexts = [];
                this.lastSave = 0;
                this.achievements = new Set();
                this.wasInDeployZone = false;
                
                this.init();
            }
            
            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height / 2;
                
                this.setupInput();
                this.initZones();
                this.loadGame();
                
                requestAnimationFrame((t) => this.gameLoop(t));
                setInterval(() => this.secondUpdate(), 1000);
            }
            
            resizeCanvas() {
                const gameArea = document.querySelector('.game-area');
                this.canvas.width = gameArea.clientWidth;
                this.canvas.height = gameArea.clientHeight;
            }
            
            setupInput() {
                // ÈîÆÁõò‰∫ã‰ª∂
                window.addEventListener('keydown', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (this.keys.hasOwnProperty(e.key)) {
                        this.keys[e.key] = false;
                    }
                });
                
                // Ëß¶Êë∏‰∫ã‰ª∂ - ÊîπËøõÁâà
                let touchStartTime = 0;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.touchId !== null) return;
                    
                    touchStartTime = Date.now();
                    const touch = e.touches[0];
                    this.touchId = touch.identifier;
                    const rect = this.canvas.getBoundingClientRect();
                    this.touchStartX = touch.clientX - rect.left;
                    this.touchStartY = touch.clientY - rect.top;
                    this.touchActive = true;
                    this.player.targetX = this.touchStartX;
                    this.player.targetY = this.touchStartY;
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touchActive || this.touchId === null) return;
                    
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === this.touchId) {
                            const touch = e.touches[i];
                            const rect = this.canvas.getBoundingClientRect();
                            this.player.targetX = touch.clientX - rect.left;
                            this.player.targetY = touch.clientY - rect.top;
                            break;
                        }
                    }
                }, { passive: false });
                
                const endTouch = (e) => {
                    e.preventDefault();
                    let found = false;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === this.touchId) {
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        this.touchActive = false;
                        this.touchId = null;
                        this.player.targetX = null;
                        this.player.targetY = null;
                    }
                };
                
                this.canvas.addEventListener('touchend', endTouch);
                this.canvas.addEventListener('touchcancel', endTouch);
                
                // Èº†Ê†áÁÇπÂáªÁßªÂä®
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = e.clientX - rect.left;
                    this.player.targetY = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.player.targetX = null;
                    this.player.targetY = null;
                });
                
                // Èò≤Ê≠¢È°µÈù¢ÊªöÂä®
                document.body.addEventListener('touchmove', (e) => {
                    if (e.target === this.canvas) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
            
            initZones() {
                const zoneCount = 5;
                for (let i = 0; i < zoneCount; i++) {
                    this.zones.push({
                        x: (0.15 + Math.random() * 0.7) * this.canvas.width,
                        y: (0.15 + Math.random() * 0.7) * this.canvas.height,
                        radius: 60 + Math.random() * 40,
                        type: Math.random() > 0.3 ? 'nutrient' : 'energy',
                        richness: 0.5 + Math.random() * 0.5
                    });
                }
            }
            
            gameLoop(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                
                this.frameCount++;
                if (timestamp - this.lastFpsTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsTime = timestamp;
                    document.getElementById('fpsCounter').textContent = this.fps;
                }
                
                if (!this.paused) {
                    this.update(deltaTime);
                    this.render();
                }
                
                requestAnimationFrame((t) => this.gameLoop(t));
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                this.updatePlayerMovement(dt);
                this.updateResources(dt);
                this.updateParticles(dt);
                this.updateFloatingTexts(dt);
                
                if (this.stage === 2) {
                    this.updateStage2(dt);
                } else if (this.stage === 3) {
                    this.updateStage3(dt);
                }
                
                this.checkEvolution();
                this.updateDeployUI();
                
                if (Date.now() - this.lastSave > 60000) {
                    this.saveGame();
                    this.lastSave = Date.now();
                }
            }
            
            updatePlayerMovement(dt) {
                let dx = 0;
                let dy = 0;
                let usingKeyboard = false;
                
                if (this.keys.w || this.keys.ArrowUp) { dy -= 1; usingKeyboard = true; }
                if (this.keys.s || this.keys.ArrowDown) { dy += 1; usingKeyboard = true; }
                if (this.keys.a || this.keys.ArrowLeft) { dx -= 1; usingKeyboard = true; }
                if (this.keys.d || this.keys.ArrowRight) { dx += 1; usingKeyboard = true; }
                
                // ‰ºòÂÖà‰ΩøÁî®ÈîÆÁõòËæìÂÖ•ÔºåËß¶Êë∏‰Ωú‰∏∫Â§áÈÄâ
                if (!usingKeyboard && this.player.targetX !== null && this.player.targetY !== null) {
                    const targetDx = this.player.targetX - this.player.x;
                    const targetDy = this.player.targetY - this.player.y;
                    const dist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                    
                    if (dist > 5) {
                        dx = targetDx / dist;
                        dy = targetDy / dist;
                    }
                }
                
                if (dx !== 0 || dy !== 0) {
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                    }
                }
                
                const accel = 800;
                const friction = 0.85;
                
                this.player.vx += dx * accel * dt;
                this.player.vy += dy * accel * dt;
                
                this.player.vx *= friction;
                this.player.vy *= friction;
                
                const speed = Math.sqrt(this.player.vx * this.player.vx + this.player.vy * this.player.vy);
                const maxSpeed = this.player.speed + this.upgrades.speed.level * this.upgrades.speed.effect;
                if (speed > maxSpeed) {
                    this.player.vx = (this.player.vx / speed) * maxSpeed;
                    this.player.vy = (this.player.vy / speed) * maxSpeed;
                }
                
                this.player.x += this.player.vx * dt;
                this.player.y += this.player.vy * dt;
                
                this.player.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.y));
            }
            
            updateResources(dt) {
                this.resourceRates = { nutrients: 0, energy: 0, signals: 0, food: 0, swarmPoints: 0 };
                const efficiency = 1 + this.upgrades.efficiency.level * this.upgrades.efficiency.effect;
                
                // ÈáçÁΩÆËµÑÊ∫ê‰∏äÈôêÂà∞Âü∫Á°ÄÂÄº
                this.resourceCaps.nutrients = 100 + this.resources.cells * 20;
                this.resourceCaps.energy = 100 + this.resources.cells * 15;
                
                this.facilities.forEach(facility => {
                    const type = this.getFacilityType(facility.type);
                    if (!type) return;
                    
                    if (type.consumption) {
                        let canConsume = true;
                        for (let [res, amount] of Object.entries(type.consumption)) {
                            if (this.resources[res] < amount * dt) {
                                canConsume = false;
                                break;
                            }
                        }
                        
                        if (canConsume) {
                            for (let [res, amount] of Object.entries(type.consumption)) {
                                this.resources[res] -= amount * dt;
                            }
                            
                            if (type.production) {
                                for (let [res, amount] of Object.entries(type.production)) {
                                    const produced = amount * efficiency * facility.level * dt;
                                    this.resources[res] = Math.min(
                                        this.resources[res] + produced,
                                        this.resourceCaps[res] || Infinity
                                    );
                                    this.resourceRates[res] += amount * efficiency * facility.level;
                                }
                            }
                        }
                    } else if (type.production) {
                        for (let [res, amount] of Object.entries(type.production)) {
                            const produced = amount * efficiency * facility.level * dt;
                            this.resources[res] = Math.min(
                                this.resources[res] + produced,
                                this.resourceCaps[res] || Infinity
                            );
                            this.resourceRates[res] += amount * efficiency * facility.level;
                        }
                    }
                    
                    if (type.effect) {
                        if (type.effect.capNutrients) {
                            this.resourceCaps.nutrients += type.effect.capNutrients;
                        }
                        if (type.effect.capEnergy) {
                            this.resourceCaps.energy += type.effect.capEnergy;
                        }
                    }
                });
                
                if (this.stage >= 3) {
                    const ownedTerritories = this.territoryData.filter(t => t.owned).length;
                    this.resources.territories = ownedTerritories;
                    const income = ownedTerritories * 2 * dt;
                    this.resources.food = Math.min(
                        this.resources.food + income,
                        this.resourceCaps.food
                    );
                    this.resourceRates.food += ownedTerritories * 2;
                    
                    const swarmBonus = Math.floor(this.swarmSize / 10) * 0.1;
                    this.resources.swarmPoints += (ownedTerritories * 0.5 * (1 + swarmBonus)) * dt;
                }
                
                this.applyResourceCaps();
            }
            
            applyResourceCaps() {
                for (let key in this.resourceCaps) {
                    if (this.resources[key] > this.resourceCaps[key]) {
                        this.resources[key] = this.resourceCaps[key];
                    }
                }
            }
            
            updateStage2(dt) {
                this.checkOrgans();
            }
            
            updateStage3(dt) {
                this.swarmSize = this.resources.cells + Math.floor(this.resources.swarmPoints / 10);
            }
            
            updateParticles(dt) {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    p.alpha = p.life / p.maxLife;
                    return p.life > 0;
                });
            }
            
            updateFloatingTexts(dt) {
                this.floatingTexts = this.floatingTexts.filter(t => {
                    t.y -= 30 * dt;
                    t.life -= dt;
                    t.element.style.opacity = t.life;
                    t.element.style.transform = `translateY(${t.y - t.startY}px) scale(${1 + (1 - t.life) * 0.5})`;
                    if (t.life <= 0) {
                        t.element.remove();
                        return false;
                    }
                    return true;
                });
            }
            
            render() {
                // ÂÆåÂÖ®Ê∏ÖÈô§ÁîªÂ∏ÉÔºåÈÅøÂÖçÊãñÂΩ±
                this.ctx.fillStyle = '#0a1628';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ÁªòÂà∂ËÉåÊôØÊ∏êÂèò
                const bgGradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                bgGradient.addColorStop(0, '#0a1628');
                bgGradient.addColorStop(0.5, '#1a2a4a');
                bgGradient.addColorStop(1, '#0d1b2a');
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.renderZones();
                this.renderFacilities();
                this.renderPlayer();
                this.renderParticles();
                
                if (this.stage === 2) {
                    this.renderStage2();
                } else if (this.stage === 3) {
                    this.renderStage3();
                }
            }
            
            renderZones() {
                this.zones.forEach(zone => {
                    const gradient = this.ctx.createRadialGradient(
                        zone.x, zone.y, 0,
                        zone.x, zone.y, zone.radius
                    );
                    
                    if (zone.type === 'nutrient') {
                        gradient.addColorStop(0, `rgba(0, 255, 136, ${0.2 * zone.richness})`);
                        gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                    } else {
                        gradient.addColorStop(0, `rgba(255, 200, 0, ${0.2 * zone.richness})`);
                        gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                    }
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = zone.type === 'nutrient' ? 'rgba(0, 255, 136, 0.3)' : 'rgba(255, 200, 0, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    this.ctx.font = '20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(zone.type === 'nutrient' ? 'üçÉ' : '‚ö°', zone.x, zone.y);
                });
            }
            
            renderFacilities() {
                this.facilities.forEach(facility => {
                    const type = this.getFacilityType(facility.type);
                    if (!type) return;
                    
                    const gradient = this.ctx.createRadialGradient(
                        facility.x, facility.y, 0,
                        facility.x, facility.y, type.range
                    );
                    gradient.addColorStop(0, 'rgba(0, 200, 255, 0.1)');
                    gradient.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(facility.x, facility.y, type.range, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.font = '24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(type.icon, facility.x, facility.y);
                    
                    if (facility.level > 1) {
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText(`Lv.${facility.level}`, facility.x, facility.y + 20);
                    }
                });
            }
            
            renderPlayer() {
                const { x, y, radius, vx, vy } = this.player;
                
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, radius * 3);
                gradient.addColorStop(0, 'rgba(0, 255, 200, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 255, 200, 0)');
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 200, 180, 0.8)';
                this.ctx.fill();
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 0.3, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 100, 150, 0.9)';
                this.ctx.fill();
                
                const speed = Math.sqrt(vx * vx + vy * vy);
                if (speed > 10) {
                    const angle = Math.atan2(vy, vx);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
                    this.ctx.lineTo(x + Math.cos(angle) * (radius + 15), y + Math.sin(angle) * (radius + 15));
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }
                
                const time = Date.now() / 200;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time;
                    const x1 = x + Math.cos(angle) * radius;
                    const y1 = y + Math.sin(angle) * radius;
                    const x2 = x + Math.cos(angle) * (radius + 8);
                    const y2 = y + Math.sin(angle) * (radius + 8);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.strokeStyle = 'rgba(0, 255, 200, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }
            
            renderStage2() {
                const nerveFacilities = this.facilities.filter(f => f.type === 'nerveNode');
                if (nerveFacilities.length > 1) {
                    this.ctx.strokeStyle = 'rgba(136, 68, 255, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([3, 3]);
                    
                    for (let i = 0; i < nerveFacilities.length - 1; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(nerveFacilities[i].x, nerveFacilities[i].y);
                        this.ctx.lineTo(nerveFacilities[i + 1].x, nerveFacilities[i + 1].y);
                        this.ctx.stroke();
                    }
                    this.ctx.setLineDash([]);
                }
            }
            
            renderStage3() {
                this.territoryData.forEach(t => {
                    if (t.owned) {
                        const x = t.x * this.canvas.width;
                        const y = t.y * this.canvas.height;
                        
                        const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, 80);
                        gradient.addColorStop(0, 'rgba(0, 255, 136, 0.2)');
                        gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 80, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.font = '30px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('ü™∏', x, y);
                    }
                });
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const fishCount = Math.min(this.swarmSize, 30);
                
                for (let i = 0; i < fishCount; i++) {
                    const angle = (i / fishCount) * Math.PI * 2 + Date.now() / 3000;
                    const r = 100 + Math.sin(angle * 3) * 20;
                    const fx = centerX + Math.cos(angle) * r;
                    const fy = centerY + Math.sin(angle) * r;
                    
                    this.ctx.save();
                    this.ctx.translate(fx, fy);
                    this.ctx.rotate(angle + Math.PI / 2);
                    
                    this.ctx.fillStyle = '#00aaff';
                    this.ctx.beginPath();
                    this.ctx.ellipse(0, 0, 12, 6, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#0088cc';
                    this.ctx.beginPath();
                    this.ctx.moveTo(-10, 0);
                    this.ctx.lineTo(-16, -4);
                    this.ctx.lineTo(-16, 4);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            renderParticles() {
                this.particles.forEach(p => {
                    this.ctx.globalAlpha = p.alpha;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
            }
            
            getFacilityType(type) {
                if (this.stage === 1) return this.facilityTypes[type];
                if (this.stage === 2) return this.facilityTypesStage2[type];
                if (this.stage === 3) return this.facilityTypesStage3[type];
                return null;
            }
            
            getAllFacilityTypes() {
                if (this.stage === 1) return this.facilityTypes;
                if (this.stage === 2) return this.facilityTypesStage2;
                if (this.stage === 3) return this.facilityTypesStage3;
                return {};
            }
            
            canDeploy(type) {
                const facilityType = this.getFacilityType(type);
                if (!facilityType) return false;
                
                for (let [res, amount] of Object.entries(facilityType.cost)) {
                    if (this.resources[res] < amount) return false;
                }
                
                const limit = this.getFacilityLimit();
                if (this.facilities.length >= limit) return false;
                
                return true;
            }
            
            getFacilityLimit() {
                if (this.stage === 1) return this.resources.cells;
                if (this.stage === 2) return this.resources.cells + this.resources.nerveCells;
                if (this.stage === 3) return Math.floor(this.swarmSize / 5) + 1;
                return 1;
            }
            
            isInDeployZone() {
                return this.zones.some(zone => {
                    const dx = this.player.x - zone.x;
                    const dy = this.player.y - zone.y;
                    return Math.sqrt(dx * dx + dy * dy) < zone.radius;
                });
            }
            
            deployFacility(type) {
                if (!this.canDeploy(type)) return;
                
                const facilityType = this.getFacilityType(type);
                
                for (let [res, amount] of Object.entries(facilityType.cost)) {
                    this.resources[res] -= amount;
                }
                
                this.facilities.push({
                    type: type,
                    x: this.player.x,
                    y: this.player.y,
                    level: 1,
                    createdAt: Date.now()
                });
                
                this.spawnParticles(this.player.x, this.player.y, 10, '#00ffff');
                this.showFloatingText(this.player.x, this.player.y - 30, `ÈÉ®ÁΩ≤ ${facilityType.name}!`, '#00ffff');
                
                this.updateFacilityUI();
                
                if (this.facilities.length >= 3 && !this.achievements.has('builder')) {
                    this.unlockAchievement('builder', 'Âª∫ËÆæËÄÖ', 'ÈÉ®ÁΩ≤3‰∏™ËÆæÊñΩ');
                }
            }
            
            upgradeFacility(index) {
                const facility = this.facilities[index];
                if (!facility) return;
                
                const upgradeCost = Math.floor(20 * Math.pow(1.5, facility.level - 1));
                
                if (this.resources.energy >= upgradeCost) {
                    this.resources.energy -= upgradeCost;
                    facility.level++;
                    
                    this.spawnParticles(facility.x, facility.y, 8, '#00ff88');
                    this.showFloatingText(facility.x, facility.y - 30, `ÂçáÁ∫ßËá≥ Lv.${facility.level}!`, '#00ff88');
                    
                    this.updateFacilityUI();
                }
            }
            
            removeFacility(index) {
                const facility = this.facilities[index];
                if (!facility) return;
                
                const type = this.getFacilityType(facility.type);
                if (type) {
                    for (let [res, amount] of Object.entries(type.cost)) {
                        this.resources[res] = Math.min(
                            this.resources[res] + Math.floor(amount * 0.5),
                            this.resourceCaps[res] || Infinity
                        );
                    }
                }
                
                this.spawnParticles(facility.x, facility.y, 5, '#ff5555');
                this.facilities.splice(index, 1);
                this.updateFacilityUI();
            }
            
            updateDeployUI() {
                const inZone = this.isInDeployZone();
                const deployPanel = document.getElementById('deployPanel');
                const statusEl = document.getElementById('deployStatus');
                
                // ÊªëÂá∫/ÊªëÂÖ•Èù¢Êùø - ‰ΩøÁî®Áä∂ÊÄÅÂèòÂåñÊ£ÄÊµã
                if (inZone !== this.wasInDeployZone) {
                    if (inZone) {
                        deployPanel.classList.add('visible');
                    } else {
                        deployPanel.classList.remove('visible');
                    }
                    this.wasInDeployZone = inZone;
                }
                
                if (statusEl) {
                    if (inZone) {
                        statusEl.textContent = '‚úì ÂèØÈÉ®ÁΩ≤';
                        statusEl.className = 'deploy-status in-range';
                    } else {
                        statusEl.textContent = 'ÁßªÂä®Âà∞ËµÑÊ∫êÂå∫';
                        statusEl.className = 'deploy-status';
                    }
                }
                
                // ÊØè10Â∏ßÊõ¥Êñ∞‰∏ÄÊ¨°ÈÉ®ÁΩ≤ÊåâÈíÆÔºàËäÇÊµÅÔºâ
                if (this.frameCount % 10 !== 0) return;
                
                const gridId = this.stage === 1 ? 'deployGrid' : this.stage === 2 ? 'deployGrid2' : 'deployGrid3';
                const grid = document.getElementById(gridId);
                if (!grid) return;
                
                // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞ÔºàÊØîËæÉÂΩìÂâçÁä∂ÊÄÅÂíå‰∏äÊ¨°Áä∂ÊÄÅÔºâ
                const types = this.getAllFacilityTypes();
                let html = '';
                
                for (let [key, type] of Object.entries(types)) {
                    const canDeployNow = this.canDeploy(key) && inZone;
                    
                    let costText = '';
                    for (let [res, amount] of Object.entries(type.cost)) {
                        const hasEnough = this.resources[res] >= amount;
                        costText += `<span style="color: ${hasEnough ? '#00ff88' : '#ff5555'}" data-res="${res}">${amount}${this.getResourceShort(res)}</span> `;
                    }
                    
                    html += `
                        <button class="deploy-btn" onclick="game.deployFacility('${key}')" ${canDeployNow ? '' : 'disabled'}>
                            <span class="deploy-btn-icon">${type.icon}</span>
                            <div class="deploy-btn-info">
                                <div class="deploy-btn-name">${type.name}</div>
                                <div class="deploy-btn-cost">${costText}</div>
                            </div>
                        </button>
                    `;
                }
                
                if (grid.innerHTML !== html) {
                    grid.innerHTML = html;
                }
            }
            
            updateFacilityUI() {
                const listId = this.stage === 1 ? 'facilityList' : 'facilityList2';
                const listEl = document.getElementById(listId);
                if (!listEl) return;
                
                const limit = this.getFacilityLimit();
                document.getElementById('facilityCount').textContent = this.facilities.length;
                document.getElementById('facilityLimit').textContent = limit;
                
                if (this.facilities.length === 0) {
                    listEl.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.4); padding: 20px; font-size: 0.85em;">ÊöÇÊó†ËÆæÊñΩ</div>';
                    return;
                }
                
                let html = '';
                this.facilities.forEach((facility, index) => {
                    const type = this.getFacilityType(facility.type);
                    if (!type) return;
                    
                    const upgradeCost = Math.floor(20 * Math.pow(1.5, facility.level - 1));
                    const canUpgrade = this.resources.energy >= upgradeCost;
                    
                    let productionText = '';
                    if (type.production) {
                        for (let [res, amount] of Object.entries(type.production)) {
                            productionText += `+${(amount * facility.level).toFixed(1)}/s ${this.getResourceShort(res)} `;
                        }
                    }
                    
                    html += `
                        <div class="facility-item">
                            <div class="facility-icon">${type.icon}</div>
                            <div class="facility-info">
                                <div class="facility-name">${type.name} <span style="color: #00ffff;">Lv.${facility.level}</span></div>
                                <div class="facility-stats">${productionText || type.description}</div>
                            </div>
                            <div class="facility-actions">
                                <button class="facility-btn upgrade" onclick="game.upgradeFacility(${index})" ${canUpgrade ? '' : 'disabled'} title="ÂçáÁ∫ß (${upgradeCost}ËÉΩ)">
                                    ‚¨ÜÔ∏è
                                </button>
                                <button class="facility-btn remove" onclick="game.removeFacility(${index})" title="ÊãÜÈô§">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                listEl.innerHTML = html;
            }
            
            getResourceName(res) {
                const names = {
                    nutrients: 'Ëê•ÂÖª', energy: 'ËÉΩÈáè', cells: 'ÁªÜËÉû',
                    food: 'È£üÁâ©', swarmPoints: 'Áæ§‰ΩìÁÇπ'
                };
                return names[res] || res;
            }
            
            getResourceShort(res) {
                const shorts = {
                    nutrients: 'Ëê•', energy: 'ËÉΩ', cells: 'ËÉû',
                    food: 'È£ü', swarmPoints: 'Áæ§', signals: '‰ø°'
                };
                return shorts[res] || res.substring(0, 1);
            }
            
            checkOrgans() {
                const nerveCount = this.facilities.filter(f => f.type === 'nerveNode').length;
                const muscleCount = this.facilities.filter(f => f.type === 'muscleTissue').length;
                const digestiveCount = this.facilities.filter(f => f.type === 'digestiveGland').length;
                
                if (!this.organs.heart.formed &&
                    muscleCount >= this.organs.heart.required.muscle &&
                    nerveCount >= this.organs.heart.required.nerve) {
                    this.organs.heart.formed = true;
                    this.unlockAchievement('heart', 'ÂøÉËÑèÂΩ¢Êàê', 'ÂΩ¢ÊàêÂøÉËÑèÂô®ÂÆò');
                }
                
                if (!this.organs.brain.formed &&
                    nerveCount >= this.organs.brain.required.nerve &&
                    muscleCount >= this.organs.brain.required.muscle) {
                    this.organs.brain.formed = true;
                    this.unlockAchievement('brain', 'Â§ßËÑëÂΩ¢Êàê', 'ÂΩ¢ÊàêÂ§ßËÑëÂô®ÂÆò');
                }
                
                if (!this.organs.digestive.formed &&
                    digestiveCount >= this.organs.digestive.required.digestive &&
                    muscleCount >= this.organs.digestive.required.muscle) {
                    this.organs.digestive.formed = true;
                    this.unlockAchievement('digestive', 'Ê∂àÂåñÁ≥ªÁªü', 'ÂΩ¢ÊàêÊ∂àÂåñÁ≥ªÁªü');
                }
            }
            
            checkEvolution() {
                let progress = 0;
                let canEvolve = false;
                
                if (this.stage === 1) {
                    const facilityProgress = Math.min(this.facilities.length / 3, 1);
                    const energyProgress = Math.min(this.resources.energy / 100, 1);
                    progress = (facilityProgress + energyProgress) / 2 * 100;
                    canEvolve = this.facilities.length >= 3 && this.resources.energy >= 100;
                } else if (this.stage === 2) {
                    const organsFormed = Object.values(this.organs).filter(o => o.formed).length;
                    const organProgress = organsFormed / 3;
                    const facilityProgress = Math.min(this.facilities.length / 8, 1);
                    progress = (organProgress + facilityProgress) / 2 * 100;
                    canEvolve = organsFormed === 3 && this.facilities.length >= 8;
                } else if (this.stage === 3) {
                    const territoryProgress = Math.min(this.resources.territories / 5, 1);
                    const swarmProgress = Math.min(this.swarmSize / 50, 1);
                    progress = (territoryProgress + swarmProgress) / 2 * 100;
                    canEvolve = this.resources.territories >= 5 && this.swarmSize >= 50;
                }
                
                document.getElementById('evolutionFill').style.width = progress + '%';
                document.getElementById('evolutionPercent').textContent = Math.floor(progress) + '%';
                
                const evolveBtn = document.getElementById('evolveBtn');
                if (canEvolve) {
                    evolveBtn.classList.add('active');
                } else {
                    evolveBtn.classList.remove('active');
                }
            }
            
            attemptEvolution() {
                let canEvolve = false;
                
                if (this.stage === 1) {
                    canEvolve = this.facilities.length >= 3 && this.resources.energy >= 100;
                } else if (this.stage === 2) {
                    const organsFormed = Object.values(this.organs).filter(o => o.formed).length;
                    canEvolve = organsFormed === 3 && this.facilities.length >= 8;
                } else if (this.stage === 3) {
                    canEvolve = this.resources.territories >= 5 && this.swarmSize >= 50;
                }
                
                if (canEvolve) {
                    this.evolve();
                }
            }
            
            evolve() {
                const effect = document.getElementById('evolutionEffect');
                effect.classList.add('active');
                setTimeout(() => effect.classList.remove('active'), 2000);
                
                this.facilities = [];
                this.stage++;
                
                if (this.stage === 2) {
                    document.getElementById('unicellularContent').style.display = 'none';
                    document.getElementById('differentiationContent').style.display = 'block';
                    this.resources.cells = Math.max(this.resources.cells, 5);
                    this.unlockAchievement('multicellular', 'Â§öÁªÜËÉûÁîüÁâ©', 'ËøõÂåñÂà∞Â§öÁªÜËÉûÈò∂ÊÆµ');
                    
                    this.zones = [];
                    for (let i = 0; i < 6; i++) {
                        this.zones.push({
                            x: (0.1 + Math.random() * 0.8) * this.canvas.width,
                            y: (0.1 + Math.random() * 0.8) * this.canvas.height,
                            radius: 70 + Math.random() * 30,
                            type: ['nutrient', 'energy', 'signal'][Math.floor(Math.random() * 3)],
                            richness: 0.6 + Math.random() * 0.4
                        });
                    }
                } else if (this.stage === 3) {
                    document.getElementById('differentiationContent').style.display = 'none';
                    document.getElementById('marineContent').style.display = 'block';
                    this.swarmSize = this.resources.cells;
                    this.unlockAchievement('marine', 'Êµ∑Ê¥ãÁîüÁâ©', 'ËøõÂåñÂà∞Êµ∑Ê¥ãÁîüÁâ©Èò∂ÊÆµ');
                    
                    this.zones = [];
                    this.territoryData.forEach(t => {
                        if (t.owned) {
                            this.zones.push({
                                x: t.x * this.canvas.width,
                                y: t.y * this.canvas.height,
                                radius: 100,
                                type: 'territory',
                                richness: 1
                            });
                        }
                    });
                } else if (this.stage === 4) {
                    alert('ÊÅ≠Âñú!‰Ω†Â∑≤ÂÆåÊàêMVPÊâÄÊúâÈò∂ÊÆµ!ÂêéÁª≠ÂÜÖÂÆπÂºÄÂèë‰∏≠...');
                    this.stage = 3;
                    return;
                }
                
                this.updateStageUI();
                this.updateFacilityUI();
                this.saveGame();
            }
            
            updateStageUI() {
                const stageNames = ['', 'ÂçïÁªÜËÉû', 'Â§öÁªÜËÉû', 'Êµ∑Ê¥ãÁîüÁâ©', 'ÈôÜÂú∞ÁîüÁâ©'];
                document.getElementById('stageName').textContent = stageNames[this.stage];
                document.getElementById('stageNumber').textContent = this.stage;
            }
            
            secondUpdate() {
                this.playTime++;
                const hours = Math.floor(this.playTime / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((this.playTime % 3600) / 60).toString().padStart(2, '0');
                const seconds = (this.playTime % 60).toString().padStart(2, '0');
                document.getElementById('playTime').textContent = `${hours}:${minutes}:${seconds}`;
                
                this.updateUI();
            }
            
            updateUI() {
                this.updateResourcesUI();
                this.updateFacilityUI();
                
                if (this.stage === 2) {
                    this.updateStage2UI();
                } else if (this.stage === 3) {
                    this.updateStage3UI();
                }
            }
            
            updateResourcesUI() {
                const bar = document.getElementById('resourcesBar');
                let html = '';
                
                // Èò∂ÊÆµ1ËµÑÊ∫ê
                html += this.createResourceMini('üçÉ', this.resources.nutrients, this.resourceRates.nutrients);
                html += this.createResourceMini('‚ö°', this.resources.energy, this.resourceRates.energy);
                
                // Èò∂ÊÆµ2ËµÑÊ∫ê
                if (this.stage >= 2) {
                    html += this.createResourceMini('üì°', Math.floor(this.resources.signals), this.resourceRates.signals);
                }
                
                // Èò∂ÊÆµ3ËµÑÊ∫ê
                if (this.stage >= 3) {
                    html += this.createResourceMini('üêü', Math.floor(this.resources.food), this.resourceRates.food);
                }
                
                bar.innerHTML = html;
            }
            
            createResourceMini(icon, value, rate) {
                const rateStr = rate > 0 ? `+${this.formatNumber(rate)}/s` : (rate < 0 ? `${this.formatNumber(rate)}/s` : '');
                const rateClass = rate >= 0 ? 'rate' : 'rate negative';
                
                return `
                    <div class="resource-mini">
                        <span class="icon">${icon}</span>
                        <span class="value">${this.formatNumber(value)}</span>
                        ${rateStr ? `<span class="${rateClass}">${rateStr}</span>` : ''}
                    </div>
                `;
            }
            
            updateStage2UI() {
                const organsList = document.getElementById('organsList');
                if (!organsList) return;
                
                const nerveCount = this.facilities.filter(f => f.type === 'nerveNode').length;
                const muscleCount = this.facilities.filter(f => f.type === 'muscleTissue').length;
                const digestiveCount = this.facilities.filter(f => f.type === 'digestiveGland').length;
                
                const organs = [
                    { key: 'heart', name: 'ÂøÉËÑè', icon: '‚ù§Ô∏è', desc: `ÈúÄ:ËÇå√ó${this.organs.heart.required.muscle}Á•û√ó${this.organs.heart.required.nerve}` },
                    { key: 'brain', name: 'Â§ßËÑë', icon: 'üß†', desc: `ÈúÄ:Á•û√ó${this.organs.brain.required.nerve}ËÇå√ó${this.organs.brain.required.muscle}` },
                    { key: 'digestive', name: 'Ê∂àÂåñÁ≥ªÁªü', icon: 'üçΩÔ∏è', desc: `ÈúÄ:Ê∂à√ó${this.organs.digestive.required.digestive}ËÇå√ó${this.organs.digestive.required.muscle}` }
                ];
                
                let html = '';
                organs.forEach(o => {
                    const formed = this.organs[o.key].formed;
                    html += `
                        <div class="organ-item">
                            <div class="organ-icon ${formed ? 'formed' : ''}">${o.icon}</div>
                            <div class="organ-info">
                                <div class="organ-name">${o.name}</div>
                                <div class="organ-status">${formed ? 'Â∑≤ÂΩ¢Êàê ‚úì' : o.desc}</div>
                            </div>
                        </div>
                    `;
                });
                
                organsList.innerHTML = html;
            }
            
            updateStage3UI() {
                const territoryGrid = document.getElementById('territoryGrid');
                if (!territoryGrid) return;
                
                let html = '';
                this.territoryData.forEach(t => {
                    const className = t.owned ? 'owned' : (t.contested ? 'contested' : '');
                    const icon = t.owned ? 'ü™∏' : (t.contested ? '‚öîÔ∏è' : '‚ùì');
                    html += `
                        <div class="territory-card ${className}">
                            <div class="territory-icon">${icon}</div>
                            <div class="territory-name">${t.name}</div>
                        </div>
                    `;
                });
                territoryGrid.innerHTML = html;
                
                document.getElementById('swarmSize').textContent = this.swarmSize;
                const bonus = Math.floor(this.swarmSize / 10) * 10;
                document.getElementById('swarmBonus').textContent = `+${bonus}%`;
                const income = this.territoryData.filter(t => t.owned).length * 2;
                document.getElementById('territoryIncome').textContent = income;
            }
            
            switchTab(tab) {
                this.currentTab = tab;
                
                const activeContent = this.stage === 2 ? 'differentiationContent' : 'marineContent';
                const panel = document.getElementById(activeContent);
                if (!panel) return;
                
                panel.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                panel.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                
                event.target.classList.add('active');
                
                const tabEl = document.getElementById(tab + 'Tab') || document.getElementById(tab + 'Tab3');
                if (tabEl) tabEl.classList.add('active');
            }
            
            toggleSettings() {
                this.settingsOpen = !this.settingsOpen;
                document.getElementById('settingsPanel').classList.toggle('open', this.settingsOpen);
                document.getElementById('overlay').classList.toggle('active', this.settingsOpen);
            }
            
            formatNumber(num) {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            }
            
            unlockAchievement(id, title, desc) {
                if (this.achievements.has(id)) return;
                
                this.achievements.add(id);
                
                const popup = document.getElementById('achievementPopup');
                document.getElementById('achievementDesc').textContent = `${title}: ${desc}`;
                popup.classList.add('show');
                
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 3000);
            }
            
            spawnParticles(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = 50 + Math.random() * 50;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 0.5 + Math.random() * 0.5,
                        maxLife: 1,
                        alpha: 1,
                        size: 2 + Math.random() * 3,
                        color: color
                    });
                }
            }
            
            showFloatingText(x, y, text, color) {
                const element = document.createElement('div');
                element.className = 'floating-text';
                element.textContent = text;
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                element.style.color = color;
                document.querySelector('.game-area').appendChild(element);
                
                this.floatingTexts.push({
                    element: element,
                    x: x, y: y, startY: y, life: 1
                });
            }
            
            saveGame() {
                const saveData = {
                    stage: this.stage,
                    playTime: this.playTime,
                    resources: this.resources,
                    resourceCaps: this.resourceCaps,
                    facilities: this.facilities,
                    upgrades: this.upgrades,
                    organs: this.organs,
                    territoryData: this.territoryData,
                    swarmSize: this.swarmSize,
                    achievements: Array.from(this.achievements),
                    player: { x: this.player.x, y: this.player.y },
                    lastSave: Date.now()
                };
                
                localStorage.setItem('evolutionGameSave', JSON.stringify(saveData));
                this.showFloatingText(this.canvas.width / 2, this.canvas.height - 50, 'Â∑≤‰øùÂ≠ò!', '#00ff88');
            }
            
            loadGame() {
                const saveString = localStorage.getItem('evolutionGameSave');
                if (!saveString) return;
                
                try {
                    const saveData = JSON.parse(saveString);
                    
                    this.stage = saveData.stage || 1;
                    this.playTime = saveData.playTime || 0;
                    this.resources = { ...this.resources, ...saveData.resources };
                    this.resourceCaps = { ...this.resourceCaps, ...saveData.resourceCaps };
                    this.facilities = saveData.facilities || [];
                    this.upgrades = { ...this.upgrades, ...saveData.upgrades };
                    this.organs = saveData.organs || this.organs;
                    this.territoryData = saveData.territoryData || this.territoryData;
                    this.swarmSize = saveData.swarmSize || 1;
                    this.achievements = new Set(saveData.achievements || []);
                    
                    if (saveData.player) {
                        this.player.x = saveData.player.x || this.canvas.width / 2;
                        this.player.y = saveData.player.y || this.canvas.height / 2;
                    }
                    
                    this.updateStageUI();
                    
                    if (this.stage === 2) {
                        document.getElementById('unicellularContent').style.display = 'none';
                        document.getElementById('differentiationContent').style.display = 'block';
                    } else if (this.stage === 3) {
                        document.getElementById('unicellularContent').style.display = 'none';
                        document.getElementById('differentiationContent').style.display = 'none';
                        document.getElementById('marineContent').style.display = 'block';
                    }
                    
                    this.updateUI();
                } catch (e) {
                    console.error('Âä†ËΩΩÂ≠òÊ°£Â§±Ë¥•:', e);
                }
            }
            
            exportSave() {
                const saveString = localStorage.getItem('evolutionGameSave');
                if (saveString) {
                    const blob = new Blob([saveString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `evolution_save_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
            
            importSave() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                localStorage.setItem('evolutionGameSave', event.target.result);
                                location.reload();
                            } catch (e) {
                                alert('ÂØºÂÖ•Â≠òÊ°£Â§±Ë¥•');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
            
            hardReset() {
                if (confirm('Á°ÆÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâËøõÂ∫¶Âêó?Ê≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç!')) {
                    localStorage.removeItem('evolutionGameSave');
                    location.reload();
                }
            }
        }
        
        const game = new EvolutionGame();
    </script>
</body>
</html>
